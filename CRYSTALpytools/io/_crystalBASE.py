#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Classes and methods to parse the input (d12, d3) / output files (screen output
out / outp files) of CRYSTAL 'crystal' and 'properties' executables.
"""
import numpy as np
from warnings import warn
from copy import deepcopy

from CRYSTALpytools.base.inputbase import BlockBASE
import CRYSTALpytools.units as units

# ---------------------------- crystal input ---------------------------------#

class Crystal_inputBASE(BlockBASE):
    """
    The base class of Crystal_input class

    Args:
        geba (bool): Whether it is a normal d12 object or a GEBA subblock
    """

    def __init__(self, geba=False):
        if geba == False:
            # These are dummy keys, not printed out
            dic = {
                'GEOM'     : ['_geom', True, [], 'io._crystalBASE.Geom()'],
                'BASISSET' : ['_basisset', True, [], 'io._crystalBASE.BasisSet()'],
                'SCF'      : ['_scf', True, [], 'io._crystalBASE.SCF()'],
            }
        else:
            dic = {
                'GEOM'     : ['_geom', True, [], 'io._crystalBASE.Geom()'],
                'BASISSET' : ['_basisset', True, [], 'io._crystalBASE.BasisSet()'],
            }
        # Initialize the object to empty values
        super().__init__('', '', '\n', '\n', dic)

    @property
    def geom(self):
        """Geometry subblock"""
        self._geom._block_valid = True
        return self._geom

    @property
    def basisset(self):
        """Basis set subblock"""
        self._basisset._block_valid = True
        return self._basisset

    @property
    def scf(self):
        """SCF subblock"""
        self._scf._block_valid = True
        return self._scf

    @property
    def data(self):
        """Settings in all the attributes are summarized here."""# If objects are set separately, BASISSET might coincide with 'ENDGEOM'
        if np.all(self._basisset._block_dict['BASISSET'][0]!=None) and np.all(self._geom._block_ed!=''):
            self._geom._block_ed = ''
        return super().data

    def analyze_text(self, data):
        """
        Analyze formatted d12 file. A 'complete' d12 file with geometry, basis
        set and SCF blocks is suggested.

        Args:
            data (str): Formatted string.
        """
        import re

        data_lines = data.strip().split('\n')
        # initialization
        self.geom()
        self.basisset()
        self.scf()

        # Divide data into 3 blocks
        text = ['', '', '']
        # Case 1: No BASISSET keyword
        if 'BASISSET' not in data:
            geom_end = 1
            bs_end = 2
            end_counter = 0
            block_counter = 0
            subblock_key = ['OPTGEOM', 'FREQCALC',
                            'ANHARM', 'CPHF', 'CPKS', 'ELASTCON', 'EOS']
            for d in data_lines:
                d = d.strip()
                text[block_counter] += d + '\n'
                if d in subblock_key:
                    geom_end += 1
                    bs_end += 1
                elif 'END' in d:
                    end_counter += 1

                if end_counter == geom_end:
                    geom_end = -1
                    block_counter += 1
                elif end_counter == bs_end:
                    bs_end = -1
                    block_counter += 1
        # Case 2: BASISSET keyword
        else:
            self.basisset._block_ed = ''
            self.geom._block_ed = ''
            block_counter = 0
            for d in data_lines:
                d = d.strip()
                if d == 'BASISSET':
                    block_counter += 1
                    text[block_counter] += d + '\n'
                elif d in self.scf._block_key and block_counter == 1:  # Avoid same keywords. e.g. TOLDEE
                    block_counter += 1
                    text[block_counter] += d + '\n'
                else:
                    text[block_counter] += d + '\n'

        # The 0D geometry keyword 'MOLECULE' and the molecular crystal option 'MOLECULE'
        if 'MOLECULE' not in data_lines[1] and 'MOLECULE' in text[0]:
            text[0] = text[0].replace('MOLECULE', 'MOLECULE2')

        self.geom.analyze_text(text[0])
        self.basisset.analyze_text(text[1])
        self.scf.analyze_text(text[2], end_block_label='END')

        return self


class Geom(BlockBASE):
    """Geometry block object"""

    def __init__(self):
        bg = 'Generated by CRYSTALpytools\n'  # Set title as bg label
        ed = 'ENDGEOM\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        geom = ['CRYSTAL', 'SLAB', 'POLYMER', 'HELIX', 'MOLECULE', 'EXTERNAL', 'DLVINPUT']
        scel = ['SUPERCEL', 'SUPERCELL', 'SUPERCON', 'SCELCONF', 'SCELPHONO']
        subblock = ['TESTGEOM', 'POINTCHG', 'OPTGEOM', 'FREQCALC']
        units = ['ANGSTROM', 'BOHR', 'FRACTION']
        dic = {
            'CRYSTAL'   : [None, False, geom],
            'SLAB'      : [None, False, geom],
            'POLYMER'   : [None, False, geom],
            'HELIX'     : [None, False, geom],
            'MOLECULE'  : [None, False, geom],
            'EXTERNAL'  : [None, False, geom],
            'DLVINPUT'  : [None, False, geom],
            # ---- symmetry ----
            'BREAKELAS' : [None, False, []],
            'BREAKSYM'  : [None, False, []],
            'KEEPSYMM'  : [None, False, []],
            'MODISYMM'  : [None, False, []],
            'PURIFY'    : [None, False, []],
            'SYMMREMO'  : [None, False, []],
            'TRASREMO'  : [None, False, []],
            # ---- supercell ----
            'SUPERCEL'  : [None, False, scel],
            'SUPERCELL' : [None, False, scel],
            'SUPERCON'  : [None, False, scel],
            'SCELCONF'  : [None, False, scel],
            'SCELPHONO' : [None, False, scel],
            # ---- editing ----
            'ATOMORDE'  : [None, False, []],
            'NOSHIFT'   : [None, False, ['ORIGIN']],
            'ORIGIN'    : [None, False, ['NOSHIFT']],
            'PRIMITIV'  : [None, False, []],
            'ROTCRY'    : [None, False, []],
            'ATOMDISP'  : [None, False, []],
            'ATOMINSE'  : [None, False, []],
            'ATOMREMO'  : [None, False, []],
            # 'ATOMROT'   : [None, False, []],
            'ATOMSUBS'  : [None, False, []],
            'ELASTIC'   : [None, False, []],
            'POINTCHG'  : [None, False, ['OPTGEOM','FREQCALC','ANHARM','ELASTCON','EOS','FIELD','FIELDCON','NOBIPOLA']],
            'USESAED'   : [None, False, []],
            # ---- reduce dimension ----
            'SLABINFO'  : [None, False, []],
            'SLABCUT'   : [None, False, []],
            'NANOTUBE'  : [None, False, []],
            'SWCNT'     : [None, False, []],
            # 'NANOMULTI' : [None, False, []],
            # 'CLUSTER'   : [None, False, []],
            'CLUSTSIZE' : [None, False, []],
            'FULLEJMOL' : [None, False, []],
            'FULLE'     : [None, False, []],
            'FULLESPHE' : [None, False, []],
            'HYDROSUB'  : [None, False, []],
            'MOLECULE2' : [None, False, []], # The original 'MOLECULE' option to isolate molecules. The key does not change printed out text.
            'MOLEXP'    : [None, False, []],
            'MOLSPLIT'  : [None, False, []],
            'RAYCOV'    : [None, False, []],
            # 'NANOROD'  : [None, False, []],
            # 'NANOCRYSTAL':[None, False, []],
            # ---- fields ----
            'FIELD'     : [None, False, []],
            'FIELDCON'  : [None, False, []],
            # ---- analysis ----
            'MOLEBSSE'  : [None, False, []],
            'ATOMBSSE'  : [None, False, []],
            'PLANES'    : [None, False, []],
            'WULFF'     : [None, False, []],
            # ---- print ----
            'EXTPRT'    : [None, False, []],
            'CIFPRT'    : [None, False, []],
            'CIFPRTSYM' : [None, False, []],
            'COORPRT'   : [None, False, []],
            'FINDSYM'   : [None, False, []],
            'STRUCPRT'  : [None, False, []],
            # ---- control ----
            'ANGSTROM'  : [None, False, units],
            'BOHR'      : [None, False, units],
            'FRACTION'  : [None, False, units],
            'BOHRANGS'  : [None, False, ['BOHRCR98']],
            'BOHRCR98'  : [None, False, ['BOHRANGS']],
            'LATVEC'    : [None, False, []],
            'MAXNEIGHB' : [None, False, []],
            'NEIGHBOR'  : [None, False, []],
            'PRINTCHG'  : [None, False, []],
            # 'PRINTOUT'  : [None, False, []], # This is a subblock command
            'SETINF'    : [None, False, []],
            'SETPRINT'  : [None, False, []],
            'TESTGEOM'  : [None, False, ['OPTGEOM', 'FREQCALC']],
            # ---- blocks ----
            'OPTGEOM'   : ['_optgeom', True, subblock, 'io._crystalBASE.Optgeom()'],
            'FREQCALC'  : ['_freqcalc', True, subblock, 'io._crystalBASE.Freqcalc()'],
        }
        self._block_valid = True
        super().__init__(bg, ed, '\n', '\n', dic)

    def __call__(self, obj=''):
        """
        Call Geom subblock

        Args:
            obj (Geom | str): A 'GEOM' block object or a string in CRYSTAL d12
            format.
        """
        if type(obj) == str:
            self.__init__()
            if obj != '':
                self.analyze_text(obj)
        elif np.all(obj==None):
            self.__init__()
            self._block_valid = False
        elif type(obj) == type(self):
            self = obj
        else:
            raise ValueError('Unknown data type.')

    @property
    def data(self):
        """
        Settings in all the attributes are summarized here. Covers the data
        property in BlockBASE, to address the ambiguity of 'MOLECULE' keywords.
        """
        return super().data.replace('MOLECULE2', 'MOLECULE')

    def analyze_text(self, text):
        """Overrides the same method from parent class for title line."""
        dimen_list = ['CRYSTAL\n', 'SLAB\n', 'POLYMER\n', 'MOLECULE\n',
                      'HELIX\n', 'EXTERNAL\n', 'DLVINPUT\n']
        lines = text.split('\n')
        nlines = len(lines)
        title = lines[0]
        if title not in dimen_list: # Have title line
            self.title(title)
            text = ''.join([lines[i]+'\n' for i in range(1, nlines)])
        self = super().analyze_text(text, end_block_label='END')
        return self

    def title(self, title='Generated by CRYSTALpytools'):
        if np.all(title==None) or np.all(title==''):
            title='Generated by CRYSTALpytools'
        self._block_bg = '{}\n'.format(title)

    def crystal(self, IGR='', latt=[], atom=[], IFLAG=0, IFHR=0, IFSO=0, origin=[]):
        """
        Define 'CRYSTAL' structure

        Args:
            sg (int): Space group number. Parameter IGR in the manual
            latt (list): Minimal set of crystallographic cell parameters
            atom (list): Natom \* 4 list of conventional atomic number and 3D 
                fractional coordinates.
            IFLAG (int): See the manual
            IFHR (int): See the manual
            IFSO (int): See the manual
            origin (list): *IFSO > 1* See the manual
        """
        if np.all(IGR=='') or np.all(IGR==None):  # Keyword only or remove everything
            super().assign_keyword('CRYSTAL', [], IGR); return self

        if IFSO <= 1:
            shape = [3, 1]
            value = ['{:<3d}'.format(int(IFLAG)), '{:<3d}'.format(int(IFHR)), '{:<3d}'.format(int(IFSO)),
                     '{:<3d}'.format(int(IGR))]
        else:
            shape = [3, 3, 1]
            value = ['{:<3d}'.format(int(IFLAG)), '{:<3d}'.format(int(IFHR)), '{:<3d}'.format(int(IFSO)),
                     '{:<12.6f}'.format(origin[0]), '{:<12.6f}'.format(origin[1]), '{:<12.6f}'.format(origin[2]),
                     '{:<3d}'.format(int(IGR))]

        shape += [len(latt), ]
        value += ['{:<12.6f}'.format(i) for i in latt]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 12.8f}'.format(a[1]),
                 '{0: 12.8f}'.format(a[2]), '{0: 12.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('CRYSTAL', shape, value); return self

    def slab(self, IGR='', latt=[], atom=[]):
        """Define 'SLAB' structure"""
        if np.all(IGR==None) or np.all(IGR==''):  # Return keyword or Clean data
            super().assign_keyword('SLAB', [], IGR); return self

        shape = [1, ]
        value = ['{:<3d}'.format(int(IGR)), ]

        shape += [len(latt), ]
        value += ['{:<12.6f}'.format(i) for i in latt]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 12.8f}'.format(a[1]),
                 '{0: 12.8f}'.format(a[2]), '{0: 16.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('SLAB', shape, value); return self

    def polymer(self, IGR='', latt=[], atom=[]):
        """Define 'POLYMER' structure"""
        if np.all(IGR==None) or np.all(IGR==''):  # Return keyword or Clean data
            super().assign_keyword('POLYMER', [], IGR); return self

        shape = [1, ]
        value = ['{:<3d}'.format(int(IGR)), ]

        shape += [len(latt), ]
        value += ['{:<12.6f}'.format(i) for i in latt]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 12.8f}'.format(a[1]),
                 '{0: 16.8f}'.format(a[2]), '{0: 16.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('POLYMER', shape, value); return self

    def helix(self, N1='', N2=0, latt=[], atom=[]):
        """
        Define 'HELIX' structure

        Args:
            N1 (int): See the manual
            N2 (int): See the manual
        """
        if np.all(N1==None) or np.all(N1==''):  # Return keyword or Clean data
            super().assign_keyword('HELIX', [], N1); return self

        shape = [2, ]
        value = ['{:<3d}'.format(int(N1)), '{:<3d}'.format(int(N2)), ]

        shape += [len(latt), ]
        value += ['{:<12.6f}'.format(i) for i in latt]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 12.8f}'.format(a[1]),
                 '{0: 16.8f}'.format(a[2]), '{0: 16.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('HELIX', shape, value); return self

    def molecule(self, IGR='', atom=[]):
        """Define 'MOLECULE' structure"""
        # The 0D geometry keyword 'MOLECULE' and the molecular crystal option 'MOLECULE'
        geom = ['CRYSTAL', 'SLAB', 'POLYMER', 'HELIX', 'MOLECULE', 'EXTERNAL', 'DLVINPUT']
        for i in geom:
            if np.all(self._block_dict[i][0]!=None):
                warn("Geometry definition exists. To launch the MOLECULE to isolate molecules from lattice, use the 'geom.molecule2' method.", stacklevel=2)

        if np.all(IGR==None) or np.all(IGR==''):  # Return keyword or Clean data
            super().assign_keyword('MOLECULE', [], IGR); return self

        shape = [1, ]
        value = ['{:<3d}'.format(int(IGR)), ]

        # Format atoms - frac 12 digits, cart 16 digits
        atom = [['{:<4d}'.format(int(a[0])), '{0: 16.8f}'.format(a[1]),
                 '{0: 16.8f}'.format(a[2]), '{0: 16.8f}'.format(a[3])] for a in atom]
        atominput = super().set_list(len(atom), atom)
        shape += atominput[0]
        value += atominput[1]

        super().assign_keyword('MOLECULE', shape, value); return self

    def external(self, external=''):
        """Define 'EXTERNAL' structure"""
        super().assign_keyword('EXTERNAL', [], external); return self

    def dlvinput(self, dlvinput=''):
        """Define 'DLVINPUT' structure"""
        super().assign_keyword('DLVINPUT', [], dlvinput); return self

    # ---- symmetry ----

    def breakelas(self, mx=''):
        shape, value = super().set_matrix(mx)
        if len(shape) != 3: raise Exception('Only for 3D structures.')
        super().assign_keyword('BREAKELAS', shape, value); return self

    def breaksym(self, breaksym=''):
        super().assign_keyword('BREAKSYM', [], breaksym); return self

    def keepsymm(self, keepsymm=''):
        super().assign_keyword('KEEPSYMM', [], keepsymm); return self

    def modisymm(self, N='', flags=[]):
        shape, value = super().set_list(N, flags)
        super().assign_keyword('MODISYMM', shape, value); return self

    def purify(self, purify=''):
        super().assign_keyword('PURIFY', [], purify); return self

    def symmremo(self, symmremo=''):
        super().assign_keyword('SYMMREMO', [], symmremo); return self

    def trasremo(self, trasremo=''):
        super().assign_keyword('TRASREMO', [], trasremo); return self

    # ---- supercell ----

    def supercel(self, mx=''):
        shape, value = super().set_matrix(mx)
        super().assign_keyword('SUPERCEL', shape, value); return self

    def supercon(self, mx=''):
        shape, value = super().set_matrix(mx)
        super().assign_keyword('SUPERCON', shape, value); return self

    def scelconf(self, mx=''):
        shape, value = super().set_matrix(mx)
        super().assign_keyword('SCELCONF', shape, value); return self

    def scelphono(self, mx=''):
        shape, value = super().set_matrix(mx)
        super().assign_keyword('SCELPHONO', shape, value); return self

    # ---- editing ----

    def atomorde(self, atomorde=''):
        super().assign_keyword('ATOMORDE', [], atomorde); return self

    def noshift(self, noshift=''):
        super().assign_keyword('NOSHIFT', [], noshift); return self

    def origin(self, origin=''):
        super().assign_keyword('ORIGIN', [], origin); return self

    def primitiv(self, primitiv=''):
        super().assign_keyword('PRIMITIV', [], primitiv); return self

    def rotcry(self, key='', value=''):
        """
        ROTCRY keyword

        Args:
            key (int): 'ANGROT', 'MATROT', 'AUTO'
            value (list): 1\*3 or 3\*3 list, or not used.
        """
        if key is None or key.strip() == '':
            super().assign_keyword('ROTCRY', [], key); return self

        key = key.strip().upper()
        if key == 'ANGROT':
            shape, value = super().set_list(3, value)
            super().assign_keyword('ROTCRY', [1]+shape, [key]+value)
        elif key == 'MATROT':
            shape, value = super().set_matrix(value)
            super().assign_keyword('ROTCRY', [1]+shape, [key]+value)
        elif key == 'AUTO':
            super().assign_keyword('ROTCRY', [1], [key])
        else:
            raise Exception(f"Unknown keyword for ROTCRY: '{key}'.")
        return self

    def atomdisp(self, NDISP='', atom=[]):
        """
        ATOMDISP keyword

        Args:
            NDISP (int): See manual
            atom (list): NDISP\*4 list. Including LB, DX, DY, DZ. Same below
        """
        shape, value = super().set_list(NDISP, atom)
        super().assign_keyword('ATOMDISP', shape, value); return self

    def atominse(self, NINS='', atom=[]):
        shape, value = super().set_list(NINS, atom)
        super().assign_keyword('ATOMINSE', shape, value); return self

    def atomremo(self, NL='', atom=[]):
        shape, value = super().set_list(NL, atom)
        super().assign_keyword('ATOMREMO', shape, value); return self

    # def atomrot(self, NL='', atom=[]):
    #     """
    #     ATOMROT keyword

    #     Args:
    #         NL (int): See manual
    #         atom (list): NL\*1 list. Including LB
    #     """

    def atomsubs(self, NSOST='', atom=[]):
        shape, value = super().set_list(NSOST, atom)
        super().assign_keyword('ATOMSUBS', shape, value); return self

    def elastic(self, IDEF='', mx=''):
        shape = [1,]
        value = [IDEF,]
        out1, out2 = super().set_matrix(mx)
        shape.extend(out1)
        value.extend(out2)
        super().assign_keyword('ELASTIC', shape, value); return self

    def pointchg(self, NCH='', chg=[]):
        """
        POINTCHG keyword

        Args:
            NCH (int): See manual
            chg (list): NCH\*2 list. Cartesian coordinates and charge in primitive cell.
        """
        shape, value = super().set_list(NCH, chg)
        super().assign_keyword('POINTCHG', shape, value); return self

    def usesaed(self, delta=''):
        if delta == '' or delta is None:
            super().assign_keyword('USESAED', [], delta)
        else:
            delta = list(delta)
            super().assign_keyword('USESAED', [1 for i in range(len(delta))], delta)
        return self

    # ---- reduce dimension ----

    def slabinfo(self, hkl=''):
        super().assign_keyword('SLABINFO', [3,], hkl); return self

    def slabcut(self, hkl='', surface=None):
        super().assign_keyword('SLABCUT', [3,], hkl)
        if self._block_dict['SLABCUT'][0] != '' and self._block_dict['SLABCUT'][0] is not None:
            firstline = deepcopy(self._block_dict['SLABCUT'][0])
            if surface == '' or surface is None:
                raise Exception("Unknown type and number of layers.")
            super().assign_keyword('SLABCUT', [2,], surface)
            self._block_dict['SLABCUT'][0] = firstline + self._block_dict['SLABCUT'][0]
        return self

    def nanotube(self, vec=''):
        super().assign_keyword('NANOTUBE', [2,], vec); return self

    def swcnt(self, vec=''):
        super().assign_keyword('SWCNT', [2,], vec); return self

    # def nanomulti()

    # def cluster

    def clustsize(self, NATOCLU=''):
        super().assign_keyword('CLUSTSIZE', [1,], NATOCLU); return self

    def fullejmol(self, fullejmol=''):
        super().assign_keyword('FULLEJMOL', [], fullejmol); return self

    def fulle(self, vec='', PG='', POLY=''):
        if vec == '' or vec is None: vec = [vec,]
        if PG.upper() not in ['', 'T', 'TD', 'TH', 'O', 'OH', 'I', 'IH'] \
        or POLY.upper() not in ['TETRA', 'OCTA', 'ICOSA']:
            raise Exception(f"Unknown point group ('{PG}') or polyhedron ('{POLY}') settings.")
        super().assign_keyword('FULLE', [2, 1, 1], vec.extend([PG, POLY])); return self

    def fullesphe(self, RSPHE=''):
        super().assign_keyword('FULLESPHE', [1,], RSPHE); return self

    def hydrosub(self, NSOST='', subs=None):
        shape, value = super().set_list(NSOST, subs)
        super().assign_keyword('HYDROSUB', shape, value); return self

    def molecule2(self, NMOL='', atom=[]):
        """
        .. note::

            Corresponds to the **option** MOLECULE to isolate molecules from
            lattice. Only the method's name is changed to avoid ambiguity with
            the one to set 0D geometry.

        Args:
            NMOL (int)
            atom (list[list[int]]): NMOL\*4 list. See CRYSTAL manual.
        """
        shape, value = super().set_list(NMOL, atom)
        super().assign_keyword('MOLECULE2', shape, value); return self

    def molexp(self, latt=''):
        if latt == '' or latt is None: latt = [latt,]
        super().assign_keyword('MOLEXP', len(latt), latt); return self

    def molsplit(self, molsplit=''):
        super().assign_keyword('MOLSPLIT', [], molsplit); return self

    def raycov(self, NCOV='', atoms=None):
        shape, value = super().set_list(NCOV, atoms)
        super().assign_keyword('RAYCOV', shape, value); return self

    # ---- fields ----

    def field(self, E0MAX='', DIRE=None, SMFACT=None, IORTO=None, MUL=None, ISYM=None):
        value = [E0MAX,]; value.extend(DIRE); value.extend([SMFACT, IORTO, MUL, ISYM])
        super().assign_keyword('FIELD', [1,3,1,1,1,1], value); return self

    def fieldcon(self, E=''):
        super().assign_keyword('FIELDCON', [3,], E); return self

    # ---- analysis ----

    def molebsse(self, NMOL='', mol=None, nbr=None):
        shape, value = super().set_list(NMOL, mol)
        if len(shape) > 0:
            shape2, value2 = super().set_list(NMOL, nbr)
            shape.extend(shape2[1:]); value.extend(value2[1:])
        super().assign_keyword('MOLEBSSE', shape, value); return self

    def atombsse(self, IAT='', NSTAR=None, RMAX=None):
        super().assign_keyword('ATOMBSSE', [3,], [IAT, NSTAR, RMAX]); return self

    def planes(self, f=''):
        super().assign_keyword('PLANES', [1,], f); return self

    def wulff(self, IPLN='', hkl=None, ESURF=None):
        shape, value = super().set_list(IPLN, hkl)
        if len(shape) > 0:
            shape2, value2 = super().set_list(IPLN, ESURF)
            shape.extend(shape2[1:]); value.extend(value2[1:])
        super().assign_keyword('WULFF', shape, value); return self

    # ---- print ----

    def extprt(self, extprt=''):
        super().assign_keyword('EXTPRT', [], extprt); return self

    def cifprt(self, cifprt=''):
        super().assign_keyword('CIFPRT', [], cifprt); return self

    def cifprtsym(self, cifprtsym=''):
        super().assign_keyword('CIFPRTSYM', [], cifprtsym); return self

    def coorprt(self, coorprt=''):
        super().assign_keyword('COORPRT', [], coorprt); return self

    def findsym(self, findsym=''):
        super().assign_keyword('FINDSYM', [], findsym); return self

    def strucprt(self, strucprt=''):
        super().assign_keyword('STRUCPRT', [], strucprt); return self

    # ---- control ----

    def angstrom(self, angstrom=''):
        super().assign_keyword('ANGSTROM', [], angstrom); return self

    def bohr(self, bohr=''):
        super().assign_keyword('BOHR', [], bohr); return self

    def fraction(self, fraction=''):
        super().assign_keyword('FRACTION', [], fraction); return self

    def bohrangs(self, bohrangs=''):
        super().assign_keyword('BOHRANGS', [1,], bohrangs); return self

    def bohrcr98(self, bohrcr98=''):
        super().assign_keyword('BOHRCR98', [], bohrcr98); return self

    def latvec(self, MAXGSIZE=''):
        super().assign_keyword('LATVEC', [1,], MAXGSIZE); return self

    def maxneighb(self, MAXNEIG=''):
        super().assign_keyword('MAXNEIGHB', [1,], MAXNEIG); return self

    def neighbor(self, INEIGH=''):
        super().assign_keyword('NEIGHBOR', [1,], INEIGH); return self

    def printchg(self, printchg=''):
        super().assign_keyword('PRINTCHG', [], printchg); return self

    def setinf(self, NUM='', inf=None):
        shape, value = super().set_list(NUM, inf)
        super().assign_keyword('SETINF', shape, value); return self

    def setprint(self, NPR='', prt=None):
        shape, value = super().set_list(NPR, prt)
        super().assign_keyword('SETPRINT', shape, value); return self

    def testgeom(self, testgeom=''):
        super().assign_keyword('TESTGEOM', [], testgeom); return self

    # ---- blocks ----

    @property
    def optgeom(self):
        """Subblock object OPTGEOM"""
        self._optgeom._block_valid = True
        return self._optgeom

    @property
    def freqcalc(self):
        """Subblock object FREQCALC"""
        self._freqcalc._block_valid = True
        return self._freqcalc


class Optgeom(BlockBASE):
    """
    OPTGEOM block object
    """

    def __init__(self):
        bg = 'OPTGEOM\n'
        ed = 'ENDOPT\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        opttype = ['FULLOPTG', 'CELLONLY', 'INTREDUN', 'ITATOCEL', 'CVOLOPT']
        hess = ['HESSIDEN', 'HESSMOD1', 'HESSMOD2', 'HESSNUM']
        dic = {
            'FULLOPTG'    : [None, False, opttype],
            'FULLOPTG'    : [None, False, opttype],
            'CELLONLY'    : [None, False, opttype],
            'INTREDUN'    : [None, False, opttype],
            'ITATOCEL'    : [None, False, opttype],
            'CVOLOPT'     : [None, False, opttype],
            'HESSIDEN'    : [None, False, hess],
            'HESSMOD1'    : [None, False, hess],
            'HESSMOD2'    : [None, False, hess],
            'HESSNUM'     : [None, False, hess],
            'TOLDEG'      : [None, False, []],
            'TOLDEX'      : [None, False, []],
            'TOLDEE'      : [None, False, []],
            'MAXCYCLE'    : [None, False, []],
            'FRAGMENT'    : [None, False, []],
            'RESTART'     : [None, False, []],
            'FINALRUN'    : [None, False, []],
            'EXTPRESS'    : [None, False, []],
            'ALLOWTRUSTR' : [None, False, ['NOTRUSTR',]],
            'NOTRUSTR'    : [None, False, ['ALLOWTRUSTR', 'MAXTRADIUS', 'TRUSTRADIUS']],
            'MAXTRADIUS'  : [None, False, ['NOTRUSTR',]],
            'TRUSTRADIUS' : [None, False, ['NOTRUSTR',]],
            'ONELOG'      : [None, False, []],
            'NOXYZ'       : [None, False, []],
            'NOSYMMOPS'   : [None, False, []],
            'PRINTFORCES' : [None, False, []],
            'PRINTHESS'   : [None, False, []],
            'PRINTOPT'    : [None, False, []],
            'PRINT'       : [None, False, []],
            # ---- transition states ----
            'TSOPT'       : [None, False, []],
            'MODEFOLLOW'  : [None, False, []],
            'PATHFOLLOW'  : [None, False, []],
            'FITTOPATH'   : [None, False, []],
            'CHNGTSFOL'   : [None, False, []],
            'SCANATOM'    : [None, False, []],
            'SCANREDU'    : [None, False, []],
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    def fulloptg(self, fulloptg=''):
        super().assign_keyword('FULLOPTG', [], fulloptg); return self

    def cellonly(self, cellonly=''):
        super().assign_keyword('CELLONLY', [], cellonly); return self

    def intredun(self, intredun=''):
        super().assign_keyword('INTREDUN', [], intredun); return self

    def itatocel(self, itatocel=''):
        super().assign_keyword('ITATOCEL', [], itatocel); return self

    def cvolopt(self, cvolopt=''):
        super().assign_keyword('CVOLOPT', [], cvolopt); return self

    def hessiden(self, hessiden=''):
        super().assign_keyword('HESSIDEN', [], hessiden); return self

    def hessmod1(self, hessmod1=''):
        super().assign_keyword('HESSMOD1', [], hessmod1); return self

    def hessmod2(self, hessmod2=''):
        super().assign_keyword('HESSMOD2', [], hessmod2); return self

    def hessnum(self, hessnum=''):
        super().assign_keyword('HESSNUM', [], hessnum); return self

    def toldeg(self, TG=0.0003):
        super().assign_keyword('TOLDEG', [1,], TG); return self

    def toldex(self, TX=0.0012):
        super().assign_keyword('TOLDEX', [1,], TX); return self

    def toldee(self, IG=7):
        super().assign_keyword('TOLDEE', [1,], IG); return self

    def maxcycle(self, MAX=50):
        super().assign_keyword('MAXCYCLE', [1,], MAX); return self

    def fragment(self, NL='', LB=[]):
        """
        Args:
            NL (int | str): Number of atoms. See manual
            LB (list[int]): Label of atoms. See manual
        """
        shape, value = super().set_list(NL, LB)
        super().assign_keyword('FRAGMENT', shape, value); return self

    def restart(self, restart=''):
        super().assign_keyword('RESTART', [], restart); return self

    def finalrun(self, ICODE=4):
        super().assign_keyword('FINALRUN', [1,], ICODE); return self

    def extpress(self, pres=''):
        super().assign_keyword('EXTPRESS', [1,], pres); return self

    def allowtrustr(self, allowtrustr=''):
        super().assign_keyword('ALLOWTRUSTR', [], allowtrustr); return self

    def notrustr(self, notrustr=''):
        super().assign_keyword('NOTRUSTR', [], notrustr); return self

    def maxtradius(self, TRMAX=4.0):
        super().assign_keyword('MAXTRADIUS', [1,], TRMAX); return self

    def trustradius(self, TRADIUS=0.5):
        super().assign_keyword('TRUSTRADIUS', [1,], TRADIUS); return self

    def onelog(self, onelog=''):
        super().assign_keyword('ONELOG', [], onelog); return self

    def noxyz(self, noxyz=''):
        super().assign_keyword('NOXYZ', [], noxyz); return self

    def nosymmops(self, nosymmops=''):
        super().assign_keyword('NOSYMMOPS', [], nosymmops); return self

    def printforces(self, printforces=''):
        super().assign_keyword('PRINTFORCES', [], printforces); return self

    def printhess(self, printhess=''):
        super().assign_keyword('PRINTHESS', [], printhess); return self

    def printopt(self, printopt=''):
        super().assign_keyword('PRINTOPT', [], printopt); return self

    def print(self, prt=''):
        super().assign_keyword('PRINT', [], prt); return self

    # ---- transition states ----

    def tsopt(self, tsopt=''):
        super().assign_keyword('TSOPT', [], tsopt); return self

    def modefollow(self, MODEFOL=''):
        super().assign_keyword('MODEFOLLOW', [1,], MODEFOL); return self

    def pathfollow(self, NPATHFOL=''):
        super().assign_keyword('PATHFOLLOW', [1,], NPATHFOL); return self

    def fittopath(self, NPATHFOL2='', NPATHWEIGHT=''):
        super().assign_keyword('FITTOPATH', [2,], [NPATHFOL2, NPATHWEIGHT]); return self

    def chngtsfol(self, chngtsfol=''):
        super().assign_keyword('CHNGTSFOL', [], chngtsfol); return self

    def scanatom(self, NATSCAN='', TARGET='', MSCAN=''):
        super().assign_keyword('SCANATOM', [3,], [NATSCAN, TARGET, MSCAN]); return self

    def scanredu(self, IREDSCA='', ENDSCA='', MAXSCA=''):
        super().assign_keyword('SCANREDU', [3,], [IREDSCA, ENDSCA, MAXSCA]); return self


class Freqcalc(BlockBASE):
    """
    FREQCALC block object
    """

    def __init__(self):
        bg = 'FREQCALC\n'
        ed = 'ENDFREQ\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'NOOPTGEOM'  : [None, False, ['NOOPTGEOM', 'PREOPTGEOM']],
            'PREOPTGEOM' : ['_preoptgeom', True, ['NOOPTGEOM', 'PREOPTGEOM'], 'io._crystalBASE.Optgeom()'],
            'DISPERSION' : [None, False, []],
            'BANDS'      : [None, False, []],
            'NUMDERIV'   : [None, False, []],
            'STEPSIZE'   : [None, False, []],
            'RESTART'    : [None, False, []],
            'MODES'      : [None, False, ['MODES', 'NOMODES']],
            'NOMODES'    : [None, False, ['MODES', 'NOMODES']],
            'PRESSURE'   : [None, False, []],
            'TEMPERAT'   : [None, False, []],
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    def nooptgeom(self, nooptgeom=''):
        super().assign_keyword('NOOPTGEOM', [], nooptgeom); return self

    @property
    def preoptgeom(self):
        """
        Subblock object PREOPTGEOM
        """
        self._preoptgeom._block_valid = True
        # Change the keyword
        self._preoptgeom._block_bg = 'PREOPTGEOM\n'
        self._preoptgeom._block_ed = 'END\n'
        return self._preoptgeom

    def dispersion(self, dispersion=''):
        super().assign_keyword('DISPERSION', [], dispersion); return self

    def bands(self, ISS='', NSUB=None, NLINE=None, points=[]):
        if np.all(ISS==None) or np.all(ISS==''):
            super().assign_keyword('BANDS', [], ISS)
        else:
            shape, value = super().set_list(NLINE, points)
            super().assign_keyword('BANDS', [2, ] + shape, [ISS, NSUB] + value)
        return self

    def modes(self, modes=''):
        super().assign_keyword('MODES', [], modes); return self

    def nomodes(self, nomodes=''):
        super().assign_keyword('NOMODES', [], nomodes); return self

    def numderiv(self, N=1):
        super().assign_keyword('NUMDERIV', [1,], N); return self

    def pressure(self, NP='', P1=None, P2=None):
        super().assign_keyword('PRESSURE', [3,], [NP, P1, P2]); return self

    def restart(self, restart=''):
        super().assign_keyword('RESTART', [], restart); return self

    def stepsize(self, STEP=0.003):
        super().assign_keyword('NUMDERIV', [1,], STEP); return self

    def temperat(self, NT='', T1=None, T2=None):
        super().assign_keyword('TEMPERAT', [3,], [NT, T1, T2]); return self


class BasisSet(BlockBASE):
    """
    Basis Set block object
    """
    def __init__(self):
        bg = ''
        ed = 'ENDBS\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'BASISSET'    : [None, False, []],
            'GHOSTS'      : [None, False, []],
        }
        super().__init__(bg, ed, '\n', '\n', dic)
        self._bs_obj = None # BasisSetBASE object

    # __call__ method inherited from BlockBASE

    @property
    def data(self):
        """
        Settings in all the attributes are summarized here. Covers the data
        property in BlockBASE, to deal with user's definition of basis sets.
        """
        if self._block_valid == False:
            warn("This block is not visible. Set 'self._block_valid = True' to get data", stacklevel=2)
            return ''

        self.update_block()
        if self._block_dict['BASISSET'][0] is None and self._bs_obj is not None:
            text = self._block_bg + self._bs_obj.print_crystal()
        else:
            text = self._block_bg

        for i in [self._block_data, self._block_ed]:
            text += i
        return text

    def analyze_text(self, text):
        """
        Analyze the input and return to corresponding attributes. Add support
        to basis set strings
        """
        import re
        from CRYSTALpytools.base.basisset import BasisSetBASE

        super().analyze_text(text, bg_block_label='', end_block_label='') # force the scan of the whole range
        lines = self._block_bg.split('\n')
        usrbs = False
        for nline, line in enumerate(lines):
            line = line.strip()
            if re.match(r'^[0-9]+\s+[0-9]+$', line): # If there is a user defined basis set
                line2 = lines[nline+1].strip().split()
                if len(line2) == 5:
                    usrbs = True
                    break

        if usrbs == True: # user defined basis set
            self._block_bg = ''
            self._block_ed = 'ENDBS\n'
            ed = -1
            for nline, line in enumerate(lines):
                line = line.strip()
                if re.match(r'^99\s+0$', line):
                    ed = nline
                    break
            if ed < 0:
                raise ValueError('Valid definition of basis set does not exist')

            bsblock = ''.join([i+'\n' for i in lines])
            self._bs_obj = BasisSetBASE.from_string(bsblock)
        else: # keyword
            self._block_ed = ''

        return self

    # ---------------- Keywords ----------------
    def basisset(self, NAME=''):
        if np.all(NAME==None):
            self._block_ed = 'ENDBS\n'
        else:
            self._block_ed = ''
            if np.all(self._bs_obj!=None):
                warn("User's definition of baisis set is not empty. It will be covered by 'BASISSET' keyword.", stacklevel=2)
                self._bs_obj = None

        super().assign_keyword('BASISSET', [1,], NAME); return self

    def ghosts(self, NA='', LA=[]):
        shape, value = super().set_list(NA, LA)
        super().assign_keyword('GHOSTS', shape, value); return self

    # ---------------- User defined basis sets ----------------
    # Wrapper defined in crystal_io.Crystal_iput()
    def from_bse(self, name, z, append=False):
        """
        Download basis set definitions from `Basis Set Exchange (BSE) <https://www.basissetexchange.org/>`_.

        Args:
            name (str): Basis set's name.
            z (list[int]): List of elements, specified by conventional atomic
                numbers.
            append (bool): Whether to cover old entries. If the old entry
                contains 'BASISSET', it will be removed anyway. Useful when
                different series of basis sets are defined
        """
        from CRYSTALpytools.base.basisset import BasisSetBASE

        if np.all(self._block_dict['BASISSET'][0]!=None):
            warn("'BASISSET' keyword exists, it will be removed.", stacklevel=2)
            self._block_dict['BASISSET'][0] = None

        self._block_ed = 'ENDBS\n'

        if append == True and np.all(self._bs_obj!=None):
            self._bs_obj.atoms.extend(BasisSetBASE.from_bse(name, z).atoms)
        else:
            self._bs_obj = BasisSetBASE.from_bse(name, z)

        return self

    def from_string(self, string, fmt='crystal', append=False):
        """
        Basis set from a string

        Args:
            string (str): Basis set definition.
            fmt (str): Format string. Consistent with `BSE <https://www.basissetexchange.org/>`_
                python API. For non-CRYSTAL formats, only all-electron basis
                sets are supported. Charge of each shell will be automatically
                assigned to get charge neutral atoms.
            append (bool): Whether to cover old entries. If the old entry
                contains 'BASISSET', it will be removed anyway. Useful when
                different series of basis sets are defined
        """
        from CRYSTALpytools.base.basisset import BasisSetBASE

        if np.all(self._block_dict['BASISSET'][0]!=None):
            warn("'BASISSET' keyword exists, it will be removed.", stacklevel=2)
            self._block_dict['BASISSET'][0] = None

        self._block_ed = 'ENDBS\n'

        if append == True and np.all(self._bs_obj!=None):
            self._bs_obj.atoms.extend(BasisSetBASE.from_string(string, fmt).atoms)
        else:
            self._bs_obj = BasisSetBASE.from_string(string, fmt)

        return self

    def from_file(self, file, fmt='crystal', append=False):
        """
        Basis set from a file

        Args:
            file (file): Basis set definition.
            fmt (str): Format string. Consistent with `BSE <https://www.basissetexchange.org/>`_
                python API. For non-CRYSTAL formats, only all-electron basis
                sets are supported. Charge of each shell will be automatically
                assigned to get charge neutral atoms.
            append (bool): Whether to cover old entries. If the old entry
                contains 'BASISSET', it will be removed anyway. Useful when
                different series of basis sets are defined
        """
        from CRYSTALpytools.base.basisset import BasisSetBASE

        if np.all(self._block_dict['BASISSET'][0]!=None):
            warn("'BASISSET' keyword exists, it will be removed.", stacklevel=2)
            self._block_dict['BASISSET'][0] = None

        self._block_ed = 'ENDBS\n'

        if append == True and np.all(self._bs_obj!=None):
            self._bs_obj.atoms.extend(BasisSetBASE.from_file(file, fmt).atoms)
        else:
            self._bs_obj = BasisSetBASE.from_file(file, fmt)

        return self

    def from_obj(self, bs_obj, append=False):
        """
        Define basis set from a ``base.basisset.BasisSetBASE`` object.

        Args:
            bs_obj (BasisSetBASE)
            append (bool): Whether to cover old entries. If the old entry
                contains 'BASISSET', it will be removed anyway. Useful when
                different series of basis sets are defined
        """
        from CRYSTALpytools.base.basisset import BasisSetBASE

        if np.all(self._block_dict['BASISSET'][0]!=None):
            warn("'BASISSET' keyword exists, it will be removed.", stacklevel=2)
            self._block_dict['BASISSET'][0] = None

        self._block_ed = 'ENDBS\n'

        if append == True and np.all(self._bs_obj!=None):
            self._bs_obj.atoms.extend(bs_obj.atoms)
        else:
            self._bs_obj = bs_obj

        return self


class SCF(BlockBASE):
    """
    SCF block object
    """
    def __init__(self):
        bg = ''
        ed = 'ENDSCF\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        hamiltonian = ['RHF', 'UHF', 'ROHF', 'HF3C', 'HFSOL3C','DFT']
        dic = {
            'FIXINDEX' : [None, False, []],# Must be here
            # ---- Hamiltonian ----
            'RHF'      : [None, False, hamiltonian],
            'UHF'      : [None, False, hamiltonian],
            'ROHF'     : [None, False, hamiltonian],
            'DFT'      : ['_dft', True, hamiltonian, 'io._crystalBASE.DFT()'],# DFT sub-block
            # ---- Semi classical ----
            'HF3C'     : ['_hf3c', True, hamiltonian, 'io._crystalBASE.HF3C()'],  # HF3C sub-block
            'HFSOL3C'  : ['_hfsol3c', True, hamiltonian, 'io._crystalBASE.HF3C()'],  # HFSOL3C sub-block
            'DFTD3'    : ['_dftd3', True, [], 'io._crystalBASE.DFTD3()'],# DFTD3 sub-block
            'GCP'      : ['_gcp', True, ['GCPAUTO'], 'io._crystalBASE.GCP()'],# GCP sub-block
            'GCPAUTO'  : [None, False, ['GCP']],
            # ---- Spin ----
            'ATOMSPIN' : [None, False, []],
            # ---- SCF control ----
            'TOLDEE'   : [None, False, []],
            'GUESSP'   : [None, False, []],
            'MAXCYCLE' : [None, False, []],
            'SMEAR'    : [None, False, []],
            'LDREMO'   : [None, False, []],
            'LEVSHIFT' : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'BROYDEN']],
            # ---- Integation ----
            'SHRINK'   : [None, False, []],
            'TOLINTEG' : [None, False, ['NOBIPOLA', 'NOBIPCOU', 'NOBIPEXC']],
            'BIPOLAR'  : [None, False, ['NOBIPOLA',]],
            'BIPOSIZE' : [None, False, []],
            'EXCHSIZE' : [None, False, []],
            'NOBIPOLA' : [None, False, ['TOLINTEG', 'BIPOLAR']],
            'NOBIPCOU' : [None, False, ['TOLINTEG']],
            'NOBIPEXC' : [None, False, ['TOLINTEG']],
            # ---- Diagonalization ----
            'FMIXING'  : [None, False, []],
            'ANDERSON' : [None, False, []],
            'BROYDEN'  : [None, False, ['LEVSHIFT']],
            'DIIS'     : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'NODIIS', 'LEVSHIFT']],
            'NODIIS'   : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'NODIIS']],
            'DIISALLK' : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'NODIIS', 'LEVSHIFT']],
            'SLOSHING' : [None, False, ['DIIS', 'DIISALLK', 'SLOSHING', 'NODIIS', 'LEVSHIFT']],
            'HISTDIIS' : [None, False, ['NODIIS', 'LEVSHIFT']],
            'THREDIIS' : [None, False, ['NODIIS', 'LEVSHIFT']],
            'THRKDIIS' : [None, False, ['NODIIS', 'LEVSHIFT']],
            'SLOSHFAC' : [None, False, ['DIIS', 'DIISALLK', 'NODIIS', 'LEVSHIFT']],
            'PRTDIIS'  : [None, False, ['NODIIS', 'LEVSHIFT']],
            # ---- Post SCF ----
            'EXCHANGE' : [None, False, []],
            'POSTSCF'  : [None, False, []],
            'PPAN'     : [None, False, []],
            'GRADCAL'  : [None, False, []],
            # ---- MPP ----
            'CMPLXFAC' : [None, False, []],
            'REPLDATA' : [None, False, []],
            'STDIAG'   : [None, False, []],
            # ---- FIXINDEX ----
            'GEOM'     : ['_geom', True, ['GEOM', 'BASE', 'GEBA'], 'io._crystalBASE.Geom()'],# FIXINDEX - GEOM subblock. Must be at the end
            'BASE'     : ['_base', True, ['GEOM', 'BASE', 'GEBA'], 'io._crystalBASE.BasisSet()'],# FIXINDEX - BASE subblock. Must be at the end.
            'GEBA'     : ['_geba', True, ['GEOM', 'BASE', 'GEBA'], 'io._crystalBASE.Crystal_inputBASE(geba=True)'],# FIXINDEX - GEBA subblock. Must be at the end.
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    @property
    def data(self):
        """
        Print formatted input. Redefined to address the END keywords of
        FIXINDEX blocks
        """
        if self._geom._block_valid == True or self._base._block_valid == True or self._geba._block_valid == True:
            self._block_ed = ''
        return super().data

    # ---------------- Hamiltonian ----------------

    def rhf(self, rhf=''):
        super().assign_keyword('RHF', [], rhf)
        return self

    def uhf(self, uhf=''):
        super().assign_keyword('UHF', [], uhf)
        return self

    def rohf(self, NSPIN=''):
        super().assign_keyword('ROHF', [1,], NSPIN)
        return self

    @property
    def dft(self):
        """
        Subblock object DFT
        """
        self._dft._block_valid = True
        return self._dft

    # ---------------- Semi-classical ----------------

    @property
    def hf3c(self):
        """
        Subblock object HF3C
        """
        self._hf3c._block_valid = True
        return self._hf3c

    @property
    def hfsol3c(self):
        """
        Subblock object HFSOL3C
        """
        self._hfsol3c._block_valid = True
        return self._hfsol3c


    @property
    def dftd3(self):
        """
        Subblock object DFTD3
        """
        self._dftd3._block_valid = True
        return self._dftd3

    @property
    def gcp(self):
        """
        Subblock object GCP
        """
        self._gcp._block_valid = True
        return self._gcp

    def gcpauto(self, gcpauto=''):
        super().assign_keyword('GCPAUTO', [], gcpauto); return self

    # ---------------- Spin ----------------

    def atomspin(self, NA='', LA=[]):
        shape, value = super().set_list(NA, LA)
        super().assign_keyword('ATOMSPIN', shape, value); return self

    # ---------------- SCF control ----------------

    def toldee(self, ITOL=6):
        super().assign_keyword('TOLDEE', [1,], ITOL); return self

    def guessp(self, guessp=''):
        super().assign_keyword('GUESSP', [], guessp); return self

    def maxcycle(self, MAX=50):
        super().assign_keyword('MAXCYCLE', [1,], MAX); return self

    def ldremo(self, value=''):
        super().assign_keyword('LDREMO', [1,], value); return self

    def smear(self, WIDTH=''):
        super().assign_keyword('SMEAR', [1,], WIDTH); return self

    def levshift(self, ISHIFT='', ILOCK=''):
        super().assign_keyword('LEVSHIFT', [2,], [ISHIFT, ILOCK]); return self

    # ---------------- Integration ----------------

    def shrink(self, IS='', ISP='', IS1='', IS2='', IS3=''):
        """
        Shrink parameters.
        """
        if np.all(IS1==''):
            super().assign_keyword('SHRINK', [2,], [IS, ISP]); return self
        else:
            super().assign_keyword('SHRINK', [2, 3], [IS, ISP, IS1, IS2, IS3]); return self

    def tolinteg(self, ITOL1=7, ITOL2=7, ITOL3=7, ITOL4=7, ITOL5=14):
        super().assign_keyword('TOLINTEG', [5,], [ITOL1, ITOL2, ITOL3, ITOL4, ITOL5]); return self

    def biposize(self, ISIZE=4000000):
        super().assign_keyword('BIPOSIZE', [1,], ISIZE); return self

    def exchsize(self, ISIZE=4000000):
        super().assign_keyword('EXCHSIZE', [1,], ISIZE); return self

    def bipolar(self, ITCOUL=18, ITEXCH=14):
        super().assign_keyword('BIPOLAR', [2,], [ITCOUL, ITEXCH]); return self

    def nobipola(self, nobipola=''):
        super().assign_keyword('NOBIPOLA', [], nobipola); return self

    def nobipcou(self, nobipcou=''):
        super().assign_keyword('NOBIPCOU', [], nobipcou); return self

    def nobipexc(self, nobipexc=''):
        super().assign_keyword('NOBIPEXC', [], nobipexc); return self

    # ---------------- Diagonalization ----------------

    def fmixing(self, IPMIX=30):
        super().assign_keyword('FMIXING', [1,], IPMIX); return self

    def diis(self, diis=''):
        super().assign_keyword('DIIS', [], diis); return self

    def nodiis(self, nodiis=''):
        super().assign_keyword('NODIIS', [], nodiis); return self

    def diisallk(self, diisallk=''):
        super().assign_keyword('DIISALLK', [], diisallk); return self

    def sloshing(self, sloshing=''):
        super().assign_keyword('SLOSHING', [], sloshing); return self

    def histdiis(self, NCYC=''):
        super().assign_keyword('HISTDIIS', [1,], NCYC); return self

    def thrediis(self, DEDIIS=''):
        super().assign_keyword('THREDIIS', [1,], DEDIIS); return self

    def thrkdiis(self, DIISTHR=''):
        super().assign_keyword('THRKDIIS', [1,], DIISTHR); return self

    def sloshfac(self, FKERK=1.2):
        super().assign_keyword('SLOSHFAC', [1,], FKERK); return self

    def prtdiis(self, prtdiis=''):
        super().assign_keyword('PRTDIIS', [], prtdiis); return self

    def anderson(self, anderson=''):
        super().assign_keyword('ANDERSON', [], anderson); return self

    def broyden(self, W0=0.0001, IMIX=50, ISTART=2):
        super().assign_keyword('BROYDEN', [3,], [W0, IMIX, ISTART]); return self


    # ---------------- Post SCF ----------------

    def ppan(self, ppan=''):
        super().assign_keyword('PPAN', [], ppan); return self

    def gradcal(self, gradcal=''):
        super().assign_keyword('GRADCAL', [], gradcal); return self

    def exchange(self, exchange=''):
        super().assign_keyword('EXCHANGE', [], exchange); return self

    def postscf(self, postscf=''):
        super().assign_keyword('POSTSCF', [], postscf); return self

    # ---------------- MPP ----------------

    def cmplxfac(self, WEIGHT=2.0):
        super().assign_keyword('CMPLXFAC', [1, ], WEIGHT); return self

    def repldata(self, repldata=''):
        super().assign_keyword('REPLDATA', [], repldata); return self

    def stdiag(self, stdiag=''):
        super().assign_keyword('STDIAG', [], stdiag); return self

    # ---------------- FIXINDEX ----------------

    def fixindex(self, fixindex=''):
        """
        Fixindex keywords.

        .. note::
            'GEOM' is a ``Geom`` object. To modify keywords ('CRYSTAL' as
            example), use ``input.scf.geom.crystal()``.

            'BASE' is a ``BasisSet`` object. To define basis set from bse, use
            ``input.scf.base.from_bse()``.

            'GEBA' is a ``Crystal_inputBASE`` object. To modify keywords
            ('CRYSTAL' as example), use ``input.scf.geba.geom.crystal()``.
        """
        super().assign_keyword('FIXINDEX', [], fixindex); return self

    @property
    def geom(self):
        """
        Subblock object GEOM
        """
        self._geom._block_valid = True
        self.fixindex()
        self._geom._block_bg = 'ENDSCF\nGEOM\n'
        self._geom._block_ed = 'END\n'
        return self._geom

    @property
    def base(self):
        """
        Subblock object BASE
        """
        self._base._block_valid = True
        self.fixindex()
        self._base._block_bg = 'ENDSCF\nBASE\n'
        self._base._block_ed = 'END\n'
        return self._base

    @property
    def geba(self):
        """
        Subblock object GEBA
        """
        self._geba._block_valid = True
        self.fixindex()
        self._geba._block_bg = 'ENDSCF\nGEBA\n'
        self._geba._block_ed = 'END\n'
        self._geba.geom._block_bg = ''
        self._geba.geom._block_ed = 'END\n'
        self._geba.basisset._block_ed = ''
        return self._geba


class HF3C(BlockBASE):
    """
    HF3C block object
    """
    def __init__(self):
        bg = 'HF3C\n'
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'RESCALES8' : [None, False, []],
            'SCALEGCP'  : [None, False, []],
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    def rescales8(self, s8=''):
        super().assign_keyword('RESCALES8', [1,], s8); return self

    def scalegcp(self, gcp=''):
        super().assign_keyword('SCALEGCP', [1,], gcp); return self


class HFSOL3C(HF3C):
    """
    HFSOL3C block object
    """
    def __init__(self):
        super().__init__()
        self._block_bg = 'HFSOL3C\n'

    # __call__ method inherited from BlockBASE


class DFT(BlockBASE):
    """
    DFT block object
    """
    def __init__(self):
        bg = 'DFT\n'
        ed = 'ENDDFT\n'
        standalone_func = [
            'SVWN', 'BLYP', 'PBEXC', 'PBESOLXC', 'SOGGAXC', 'SOGGA11', 'B3PW',
            'B3LYP', 'PBE0', 'PBESOL0', 'B1WC', 'WC1LYP', 'B97H', 'PBE0-13',
            'SOGGA11X', 'MPW1PW91', 'MPW1K', 'HSE06', 'HSESOL', 'SC-BLYP',
            'HISS', 'RSHXLDA', 'WB97', 'WB97X', 'LC-WPBE', 'LC-WPBESOL',
            'LC-WBLYP', 'LC-BLYP', 'CAM-B3LYP', 'LC-PBE', 'M06L', 'REVM06L',
            'MN15L', 'SCAN', 'R2SCAN', 'B1B95', 'MPW1B95', 'MPW1B1K', 'PW6B95',
            'PWB6K', 'M05', 'M052X', 'M06', 'M062X', 'M06HF', 'MN15', 'REVM06',
            'SCAN0', 'R2SCANH', 'R2SCAN0', 'R2SCAN50', 'MN15',
            'BLYP-D3', 'PBE-D3', 'B97-D3', 'B3LYP-D3', 'PBE0-D3', 'PW1PW-D3',
            'M06-D3', 'HSE06-D3', 'HSESOL-D3', 'LC-WPBE-D3', 'B3LYP-D3',
            'PBEH3C', 'HSE3C', 'B973C', 'PBESOL03C', 'HSESOL3C'
        ]
        user_func = [
            'EXCHANGE', 'CORRELAT', 'HYBRID', 'NONLOCAL'
        ]
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        ## User defined functionals
        dic = {
            'SPIN'     : [None, False, []],
            'EXCHANGE' : [None, False, standalone_func + user_func],
            'CORRELAT' : [None, False, standalone_func + user_func],
            'HYBRID'   : [None, False, standalone_func + user_func],
            'NONLOCAL' : [None, False, standalone_func + user_func],
        }
        ## Standalone functionals
        for func in standalone_func:
            dic[func] = [None, False, standalone_func + user_func]

        ## Control keywords
        grid = ['OLDGRID', 'LGRID', 'XLGRID', 'XXLGRID', 'XXXLGRID', 'HUGEGRID',
                'RADIAL', 'ANGULAR']
        dic.update({
            'SR-OMEGA'     : [None, False,[]],
            'MR-OMEGA'     : [None, False,[]],
            'LR-OMEGA'     : [None, False,[]],
            'SR-HYB-WB97X' : [None, False,[]],
            'LSRSH-PBE'    : [None, False,[]],
            'OLDGRID'      : [None, False, grid],
            'LGRID'        : [None, False, grid],
            'XLGRID'       : [None, False, grid],
            'XXLGRID'      : [None, False, grid],
            'XXXLGRID'     : [None, False, grid],
            'HUGEGRID'     : [None, False, grid],
            'RADIAL'       : [None, False, grid],
            'ANGULAR'      : [None, False, grid],
        })
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    def spin(self, spin=''):
        super().assign_keyword('SPIN', [], spin)
        return self

    def exchange(self, ex=''):
        exlist = [
            'LDA', 'VBH', 'BECKE', 'mPW91', 'PBE', 'PBESOL', 'PWGGA', 'SOGGA',
            'WCGGA'
        ]
        if np.all(ex!='') and np.all(ex!=None):
            if ex not in exlist:
                raise ValueError('Unknown exchange functional name.')
        super().assign_keyword('EXCHANGE', [1,], ex)
        return self

    def correlat(self, cor=''):
        corlist = [
            'PWLSD', 'PZ', 'VBH', 'VWN', 'LYP', 'P86', 'PBE', 'PBESOL',
            'PWGGA', 'WL', 'B95'
        ]
        if np.all(cor!='') and np.all(cor!=None):
            if cor not in corlist:
                raise ValueError('Unknown correlation functional name.')
        super().assign_keyword('CORRELAT', [1,], cor)
        return self

    def xcfunc(self, xc=''):
        if np.all(xc!=None) and np.all(xc!=''):
            if xc not in self._block_key:
                raise ValueError('Unknown functional name.')
        super().assign_keyword(xc, [], '')
        return self

    def sr_omega(self, sr_omega=''):
        super().assign_keyword('SR-OMEGA', [1,], sr_omega); return self

    def mr_omega(self, mr_omega=''):
        super().assign_keyword('MR-OMEGA', [1,], mr_omega); return self

    def lr_omega(self, lr_omega=''):
        super().assign_keyword('LR-OMEGA', [1,], lr_omega); return self

    def sr_hyb_wb97x(self, sr_c=''):
        super().assign_keyword('SR-HYB-WB97X', [1,], sr_c); return self

    def lsrsh_pbe(self, omega='', sr_c=0., lr_c=0.):
        super().assign_keyword('LSRSH-PBE', [3,], [omega, sr_c, lr_c]); return self

    def lgrid(self, lgrid=''):
        super().assign_keyword('LGRID', [], lgrid); return self

    def oldgrid(self, oldgrid=''):
        super().assign_keyword('OLDGRID', [], oldgrid); return self

    def xlgrid(self, xlgrid=''):
        super().assign_keyword('XLGRID', [], xlgrid); return self

    def xxlgrid(self, xxlgrid=''):
        super().assign_keyword('XXLGRID', [], xxlgrid); return self

    def xxxlgrid(self, xxxlgrid=''):
        super().assign_keyword('XXXLGRID', [], xxxlgrid); return self

    def hugegrid(self, hugegrid=''):
        super().assign_keyword('HUGEGRID', [], hugegrid); return self

    def radial(self, NR='', RL=[], IL=[]):
        if np.all(NR!=None) and np.all(NR!=''):
            RL = list(RL)
            IL = list(IL)
            if NR != len(IL) and NR != len(RL):
                raise ValueError('Inconsistent definition. NR is not equal to lengths of RL or IL.')
        super().assign_keyword('RADIAL', [1, NR, NR], [NR, ] + RL + IL)
        return self

    def angular(self, NI='', AL=[], LEV=[]):
        if np.all(NI!=None) and np.all(NI!=''):
            AL = list(AL)
            LEV = list(LEV)
            if NI != len(LEV) and NI != len(AL):
                raise ValueError('Inconsistent definition. NI is not equal to lengths of AL or LEV')
        super().assign_keyword('ANGULAR', [1, NI, NI], [NI, ] + AL + LEV)
        return self


class DFTD3(BlockBASE):
    """
    DFTD3 block object
    """

    def __init__(self):
        bg = 'DFTD3\n'
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'VERSION'   : [None, False, []],
            'FUNC'      : [None, False, []],
            'ABC'       : [None, False, []],
            'S6'        : [None, False, []],
            'S8'        : [None, False, []],
            'A1'        : [None, False, ['RS6', 'RS8']],#BJ damping
            'A2'        : [None, False, ['RS6', 'RS8']],#BJ damping
            'RS6'       : [None, False, ['A1', 'A2']],#zero damping
            'RS8'       : [None, False, ['A1', 'A2']],#zero damping
            'RADIUS'    : [None, False, []],
            'CNRADIUS'  : [None, False, []],
            'ABCRADIUS' : [None, False, []],
            'PRINTC6'   : [None, False, []],
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    def version(self, NAT=4):
        super().assign_keyword('VERSION', [1,], NAT); return self

    def func(self, CHAR=''):
        super().assign_keyword('FUNC', [1,], CHAR); return self

    def abc(self, abc=''):
        super().assign_keyword('ABC', [], abc); return self

    def s6(self, s6=''):
        super().assign_keyword('S6', [1,], s6); return self

    def s8(self, s8=''):
        super().assign_keyword('S8', [1,], s8); return self

    def a1(self, a1=''):
        super().assign_keyword('A1', [1,], a1); return self

    def a2(self, a2=''):
        super().assign_keyword('A2', [1,], a2); return self

    def rs6(self, rs6=''):
        super().assign_keyword('RS6', [1,], rs6); return self

    def rs8(self, rs8=''):
        super().assign_keyword('RS8', [1,], rs8); return self

    def radius(self, radius=''):
        super().assign_keyword('RADIUS', [1,], radius); return self

    def cnradius(self, cnradius=''):
        super().assign_keyword('CNRADIUS', [1,], cnradius); return self

    def abcradius(self, abcradius=''):
        super().assign_keyword('ABCRADIUS', [1,], abcradius); return self

    def printc6(self, printc6=''):
        super().assign_keyword('PRINTC6', [], printc6); return self


class GCP(BlockBASE):
    """
    GCP block object
    """

    def __init__(self):
        bg = 'GCP\n'
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'METHOD'     : [None, False, []],
            'SIGMA'      : [None, False, []],
            'ALPHA'      : [None, False, []],
            'BETA'       : [None, False, []],
            'ETA'        : [None, False, []],
            'RADIUS'     : [None, False, []],
            'PRINTEMISS' : [None, False, []],
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    def method(self, method=''):
        super().assign_keyword('METHOD', [1, ], method); return self

    def sigma(self, sigma=''):
        super().assign_keyword('SIGMA', [1, ], sigma); return self

    def alpha(self, alpha=''):
        super().assign_keyword('ALPHA', [1, ], alpha); return self

    def beta(self, beta=''):
        super().assign_keyword('BETA', [1, ], beta); return self

    def eta(self, eta=''):
        super().assign_keyword('ETA', [1, ], eta); return self

    def radius(self, radius=''):
        super().assign_keyword('RADIUS', [1, ], radius); return self

    def printemiss(self, printemiss=''):
        super().assign_keyword('PRINTEMISS', [], printemiss); return self

# ---------------------------- properties input ------------------------------#

class PInputBlock(BlockBASE):
    """
    The base class of a 'property input block', i.e., a properties calculation,
    with non-repeated keywords.
    """
    def __init__(self):
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            # ---- Wavefunction ----
            'RDFMWF'    : [None, False, []],
            # ---- Band ----
            'BAND'      : [None, False, []], # BAND might destory NEWK
            'ANBD'      : [None, False, []],
            'BWIDTH'    : [None, False, []],
            # ---- preliminary ----
            'COMMENS'   : [None, False, []],
            'NOSYMADA'  : [None, False, []],
            'NEWK'      : [None, False, []],
            'PATO'      : [None, False, []],
            'PBAN'      : [None, False, []],
            'PGEOMW'    : [None, False, []],
            'PDIDE'     : [None, False, []],
            # 'PMP2'     : [None, False, []],
            # ---- A posteriori correlation ----
            'ADFT'      : ['_adft', True, [], 'io._crystalBASE.ADFT()'],
            'ACOR'      : ['_adft', True, [], 'io._crystalBASE.ADFT()'], # For reading only. The keyword will be changed to 'ADFT'
            'EDFT'      : ['_edft', True, [], 'io._crystalBASE.EDFT()'],
            'ENECOR'    : ['_edft', True, [], 'io._crystalBASE.EDFT()'], # For reading only. The keyword will be changed to 'EDFT'
            # ---- Charge and potential ----
            # 'PROPS2COMP'
            'CLAS'      : ['_clas', True, [], 'io._crystalBASE.CLAS()'],
            'ECHG'      : ['_echg', True, [], 'io._crystalBASE.ECHG()'],
            'ECH3'      : ['_ech3', True, [], 'io._crystalBASE.ECH3()'],
            'POTM'      : ['_potm', True, [], 'io._crystalBASE.POTM()'],
            'POT3'      : ['_pot3', True, [], 'io._crystalBASE.POT3()'],
            'POTC'      : [None, False, []],
            'HIRSHCHG'  : [None, False, []],
            'PPAN'      : [None, False, []],
            # ---- Electron momentum density ----
            'EMDLDM'    : [None, False, []],
            # 'EMDPDM'   : [None, False, []],
            # 'EMDL'
            # 'EMDP'
            'KINETEMD'  : [None, False, []],
            # ---- Multiple moments ----
            'POLI'      : [None, False, []],
            'POLSPIN'   : [None, False, []],
            # ---- spin ----
            'ANISOTRO'  : [None, False, ['ISOTROPIC', 'ANISOTRO']],
            'ISOTROPIC' : [None, False, ['ISOTROPIC', 'ANISOTRO']],
            # 'SPINCNTM'
            # ---- DOSS-like ----
            'DOSS'      : [None, False, []],
            'COOP'      : [None, False, []],
            'COHP'      : [None, False, []],
            # ---- XRD ----
            # 'XFAC'
            # 'XRDSPEC'
            # ---- Compton Profiles ----
            # 'BIDIERD'  : [None, True, []], # developing
            # ---- Transport properties ----
            # 'BOLTZTRA'
            # ---- spontaneous polarization ----
            # 'SPOLBP'
            # 'SPOLWF'
            # ---- Wannierization ---
            # 'LOCALWF' : [None, True, []], # developing
            # ---- Optical dielectric constant ----
            # 'DIEL'
            # --- Topological analysis
            # 'TOPO'
            # ---- Print ----
            # 'FMWF'
            # 'INFOGUI'
            'PSCF'     : [None, False, []],
        }
        # Initialize the object to empty values
        super().__init__('', '', '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    # ---- Wavefunction ----

    def rdfmwf(self, rdfmwf=''):
        super().assign_keyword('RDFMWF', [], rdfmwf); return self

    # ---- Band ----

    def band(self, TITLE='', NLINE='', ISS='', NSUB='', INZB='', IFNB='',
             IPLO='', LPR66='', path=[]):
        """
        ``path`` can either be a NLINE\*2 list of string (labels), or a
        NLINE\*2\*3 list of int (fractional coordinates).
        """
        if path != []:
            shape = [1, 7]
            value = [TITLE, NLINE, ISS, NSUB, INZB, IFNB, IPLO, LPR66]
            if type(path[0][0]) == str: # labels
                for i in range(NLINE):
                    shape.extend([2,])
                    value.extend([path[i][0], path[i][1]])
            else: # values
                for i in range(NLINE):
                    shape.extend([6,])
                    value.extend(['{:<2d}'.format(path[i][0][0]),
                                  '{:<2d}'.format(path[i][0][1]),
                                  '{:<4d}'.format(path[i][0][2]),
                                  '{:<2d}'.format(path[i][1][0]),
                                  '{:<2d}'.format(path[i][1][1]),
                                  '{:<4d}'.format(path[i][1][2])])
            super().assign_keyword('BAND', shape, value); return self
        else:
            super().assign_keyword('BAND', [], TITLE); return self

    def anbd(self, NK='', NB='', TOL='', *args):
        if np.all(NK==None) or np.all(NK==''):
            super().assign_keyword('ANBD', [], NK); return self
        shape = [3,]
        value = [NK, NB, TOL]
        if NK > 0:
            shape.append(NK)
        if NB > 0:
            shape.append(NB)
        for arg in args:
            value.extend(arg)
        super().assign_keyword('ANBD', shape, value); return self

    def bwidth(self, INZB='', IFNB=''):
        super().assign_keyword('BWIDTH', [2,], [INZB, IFNB]); return self

    # ---- preliminary ----

    def commens(self, ICASO=''):
        super().assign_keyword('COMMENS', [1,], ICASO); return self

    def pato(self, IBN='', NPR=''):
        super().assign_keyword('PATO', [2,], [IBN, NPR]); return self

    def nosymada(self, nosymada=''):
        super().assign_keyword('NOSYMADA', [], nosymada); return self

    def newk(self, *args):
        """
        Inputs are separated by comma.
        """
        if len(args) == 0:
            args = ['']
        if np.all(args[0]==None) or np.all(args[0]==''):
            shape = []
            value = args[0]
        else:
            if len(args) == 4:
                shape = [2, 2]
                value = args
            elif len(args) == 7:
                shape = [2, 3, 2]
                value = args
            else:
                raise ValueError('Unknown k mesh definition')
        super().assign_keyword('NEWK', shape, value); return self

    def pban(self, NB='', nbands=[]):
        shape, value = super().set_list(NB, nbands)
        super().assign_keyword('PBAN', shape, value); return self

    def pgeomw(self, pgeomw=''):
        super().assign_keyword('RDFMWF', [], pgeomw); return self

    def pdide(self, EMI='', EMX=''):
        super().assign_keyword('PDIDE', [2,], [EMI, EMX]); return self

    # ---- A posteriori correlation ----

    @property
    def adft(self):
        """
        Subblock object ADFT.
        """
        self._adft._block_valid = True
        return self._adft

    @property
    def acor(self):
        """
        Alias of block ADFT.
        """
        return self.adft

    @property
    def edft(self):
        """
        Subblock object EDFT.
        """
        self._edft._block_valid = True
        return self._edft

    @property
    def enecor(self):
        """
        Alias of block EDFT.
        """
        return self.edft

    # ---- Charge and potential ----

    @property
    def clas(self):
        """
        Subblock object CLAS. Call ``self.clas()`` to set parameters. Call
        ``self.clas.coordina()`` (for example) to set mapnet keywords.

        Args:
            IDER (int): Order of the derivative
            IFOR (int): Number of point multipoles
            charge (list): Formal net charge
            NPY (int): Number of points (MAPNET). Default 100.
        """
        self._clas._block_valid = True
        return self._clas

    @property
    def echg(self):
        """
        Subblock object ECHG. Call ``self.echg()`` to set parameters. Call
        ``self.echg.coordina()`` (for example) to set mapnet keywords.

        Args:
            IDER (int): Order of the derivative
            NPY (int): Number of points (MAPNET). Default 100.
        """
        self._echg._block_valid = True
        return self._echg

    @property
    def ech3(self):
        """
        Subblock object ECH3. Call ``self.ech3()`` to set parameters. Call
        ``self.ech3.range()`` (for example) to set 3D grid keywords.

        Args:
            NP (int): Number of points along the first direction
        """
        self._ech3._block_valid = True
        return self._ech3

    @property
    def potm(self):
        """
        Subblock object POTM. Call ``self.potm()`` to set parameters. Call
        ``self.potm.coordina()`` (for example) to set mapnet keywords.

        Args:
            IDER (int): Order of the derivative
            ITOL (int): Penetration tolerance
            NPY (int): Number of points (MAPNET). Default 100.
        """
        self._potm._block_valid = True
        return self._potm

    @property
    def pot3(self):
        """
        Subblock object POT3. Call ``self.pot3()`` to set parameters. Call
        ``self.pot3.range()`` (for example) to set 3D grid keywords.

        Args:
            NP (int): Number of points along the first direction
            ITOL (int): Penetration tolerance
        """
        self._pot3._block_valid = True
        return self._pot3

    def potc(self, ICA='', NPU='', IPA='', datagrid=[]):
        """
        ``datagrid`` corresponds to X, Y, Z, ZP, ZM and ZD parameters, which
        can be NPU\*3 (``ICA=0``), 2\*1 (``ICA=1``) or 3\*1 (``ICA=2``) lists.
        """
        if np.all(ICA==None) or np.all(ICA==''):
            super().assign_keyword('POTC', [], ICA); return self

        shape = [3,]
        data = [ICA, NPU, IPA]
        datagrid = np.array(datagrid, dtype=float)
        if ICA == 0:
            if NPU > 0:
                for i in range(NPU):
                    shape.extend([3,])
                    data.extend(datagrid[i, :])
            else:
                pass
        elif ICA == 2:
            shape.extend([2,])
            data.extend([datagird[0], datagird[1]])
        elif ICA == 3:
            shape.extend([3,])
            data.extend([datagird[0], datagird[1], datagird[2]])

        super().assign_keyword('POTC', shape, data); return self

    def hirshchg(self, hchg=''):
        super().assign_keyword('HIRSHCHG', [], hchg); return self

    def ppan(self, pchg=''):
        super().assign_keyword('PPAN', [], pchg); return self


    # ---- Electron momentum density ----

    def emdldm(self, N='', PMAX='', STEP='', IPLO='', hkl=[], ICASO='', NSA1='', NSA2=''):
        """
        ``hkl`` is a N\*3 list of int.
        """
        shape = [4,]
        value = [N, PMAX, STEP, IPLO]
        for i in range(N):
            shape.append(3)
            value.extend(hkl[i])
        shape.extend([1, 2])
        value.extend([ICASO, NSA1, NSA2])
        super().assign_keyword('EMDLDM', shape, value); return self

    def kinetemd(self, PMAX='', PINT='', STEP='', STEPDIST='', ICASO=''):
        super().assign_keyword('KINETEMD', [4, 1], [PMAX, PINT, STEP, STEPDIST, ICASO]); return self

    # ---- Multiple moments ----

    def poli(self, IDIPO='', ITENS='', LPR68=''):
        super().assign_keyword('POLI', [1, 2], [IDIPO, ITENS, LPR68]); return self

    def polspin(self, IDIPO='', ITENS='', LPR68=''):
        super().assign_keyword('POLSPIN', [1, 2], [IDIPO, ITENS, LPR68]); return self

    # ---- spin ----

    def anisotro(self, keyword='', N='', IA=''):
        """Available keywords: 'ALL', 'UNIQUE', 'SELECT'"""
        if keyword.upper() == 'SELECT':
            shape = [1, 1, N]
            value = ['SELECT', N] + list(IA[i])
        else:
            shape = [1]
            value = [keyword.upper()]
        super().assign_keyword('ANISOTRO', shape, value); return self

    def isotropic(self, keyword='', N='', IA=''):
        """Available keywords: 'ALL', 'UNIQUE', 'SELECT'"""
        if keyword.upper() == 'SELECT':
            shape = [1, 1, N]
            value = ['SELECT', N] + list(IA[i])
        else:
            shape = [1]
            value = [keyword.upper()]
        super().assign_keyword('ISOTROPIC', shape, value); return self

    # ---- DOSS like ----

    def doss(self, NPRO='', NPT='', INZB='', IFNB='', IPLO='', NPOL='', NPR='', *args):
        """
        Energy range (BMI, BMA, 2\*1 list) and projections (N, NDM,
        Nproj\*(NDM+1) list) are defined by extendable list variables. If both
        are defined, projections should be the last entry.
        """
        shape, value = self._doss_like(NPRO, NPT, INZB, IFNB, IPLO, NPOL, NPR, args)
        super().assign_keyword('DOSS', shape, value); return self

    def coop(self, NINT='', NPT='', INZB='', IFNB='', IPLO='', NPOL='', NPR='', *args):
        """
        Energy range (BMI, BMA, 2\*1 list) and projections (N, NDM,
        Nproj\*(NDM+1) list) are defined by extendable list variables. If both
        are defined, projections should be the last entry.
        """
        shape, value = self._doss_like(NINT, NPT, INZB, IFNB, IPLO, NPOL, NPR, args)
        super().assign_keyword('COOP', shape, value); return self

    def cohp(self, NINT='', NPT='', INZB='', IFNB='', IPLO='', NPOL='', NPR='', *args):
        """
        Energy range (BMI, BMA, 2\*1 list) and projections (N, NDM,
        Nproj\*(NDM+1) list) are defined by extendable list variables. If both
        are defined, projections should be the last entry.
        """
        shape, value = self._doss_like(NINT, NPT, INZB, IFNB, IPLO, NPOL, NPR, args)
        super().assign_keyword('COHP', shape, value); return self

    # ---- Print ----

    def pscf(self, pscf=''):
        super().assign_keyword('PSCF', [], pscf); return self

    # ---- methods developed for properties ----
    @staticmethod
    def _doss_like(NPRO, NPT, INZB, IFNB, IPLO, NPOL, NPR, arg):
        """
        Get formatted input text for 'DOSS'-like keywords, including 'DOSS',
        'COHP' and 'COOP'.
        """
        if np.all(NPRO==None) or np.all(NPRO==''):
            return [], NPRO

        shape = [7,]
        value = [NPRO, NPT, INZB, IFNB, IPLO, NPOL, NPR]
        if INZB < 0 and IFNB < 0:
            shape.append(2)
            value.extend(arg[0])
        if NPRO > 0:
            if INZB < 0 and IFNB < 0:
                proj = arg[1]
            else:
                proj = arg[0]

            for line in proj:
                if abs(line[0]) != len(line) - 1:
                    raise ValueError(
                        'Inconsistent size of data. N AO/atom = {}, but {} entries are given. N AO/atom is changed.'.format(line[0], len(line)-1))
                    line[0] = len(line) - 1

                shape.append(len(line))
                value.extend(line)

        return shape, value


class Properties_inputBASE(PInputBlock):
    """
    The base class of Properties_input class. At maximum 5 same 'properties'
    calculations can be appended
    """
    def __init__(self):
        super().__init__()
        self._block_ed = 'END\n'
        # These are dummy keys, not printed out
        # Add 10 blocks
        for i in range(1, 6):
            key = 'APPEND{}'.format(i)
            value='_append{}'.format(i)
            self._block_dict.update({
                # Do not use the last element - it might cause error.
                # Call PInputBlock directly in this script
                key : [value, True, [], 'PInputBlock()'],
            })
            obj = PInputBlock()
            obj._block_valid = False
            setattr(self, value, obj)

        key = list(self._block_dict.keys())
        self._block_key = sorted(set(key), key=key.index)
        # Partition lines / keywords. Important for charge difference map
        self._block_label = ['PATO', 'PBAN', 'PDIDE']

    @property
    def append1(self):
        self._append1._block_valid = True
        return self._append1

    @property
    def append2(self):
        self._append2._block_valid = True
        return self._append2

    @property
    def append3(self):
        self._append3._block_valid = True
        return self._append3

    @property
    def append4(self):
        self._append4._block_valid = True
        return self._append4

    @property
    def append5(self):
        self._append5._block_valid = True
        return self._append5

    def analyze_text(self, data):
        """
        Analyze formatted d3 file.

        Args:
            data (str): Formatted string.
        """
        import copy

        nblock = 1
        inpkeys = [[]] # No repeated keyword in the same subblock
        repkeyline = [0,]
        divkeyline = [] # Partition lines / keywords

        datalines = data.strip().split('\n')
        for nline, line in enumerate(datalines):
            if line.upper() in self._block_key:
                key = line.upper()
                if key in self._block_label:
                    divkeyline.append(nline)
                if key in inpkeys[nblock-1]: # A new subblock is needed
                    nblock += 1
                    inpkeys.append([key,])
                    repkeyline.append(nline)
                else:
                    inpkeys[nblock-1].append(key)
            else:
                continue

        if nblock == 1: # No repeat
            super().analyze_text(data)
        elif nblock > 6: # Too many repeats
            raise Exception('''The same keyword has been repeated for over 5 times.
Please consider to split the calculation into multiples to reduce repeats.''')
        else:
            # No partition line
            if len(divkeyline) == 0:
                blockline = copy.deepcopy(repkeyline)
            # Insert partition line into repeated keywords.
            else:
                blockline = []
                for div in divkeyline:
                    for rep in repkeyline:
                        if div <= rep: # echg // PATO ECHG
                            blockline.append(div)
                        else: # echg // ECHG // PATO echg
                            blockline.append(rep)
            blockline.append(len(datalines))
            for i in range(nblock):
                text = ''.join('{}\n'.format(j) for j in datalines[blockline[i]:blockline[i+1]])
                if i == 0:
                    super().analyze_text(text)
                else:
                    obj = PInputBlock()
                    obj.analyze_text(text)
                    setattr(self, '_append{}'.format(i), obj)

        return self


class EDFT(BlockBASE):
    """
    EDFT sub-block
    """
    def __init__(self):
        bg = 'EDFT\n'
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'BECKE'    : [None, False, []],
            'SAVIN'    : [None, False, []],
            'RADIAL'   : [None, False, []],
            'ANGULAR'  : [None, False, []],
            'PRINT'    : [None, False, []],
            'PRINTOUT' : [None, False, []],
            'TOLLDENS' : [None, False, []],
            'TOLLGRID' : [None, False, []],
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    def becke(self, becke=''):
        super().assign_keyword('BECKE', [], becke); return self

    def savin(self, savin=''):
        super().assign_keyword('SAVIN', [], savin); return self

    def radial(self, NR='', RL=[], IL=[]):
        if np.all(NR!=None) and np.all(NR!=''):
            RL = list(RL)
            IL = list(IL)
            if NR != len(RL) and NR != len(IL):
                raise ValueError('Inconsistent definition. NR is not equal to lengths of RL or IL')
        super().assign_keyword('RADIAL', [1, NR, NR], [NR,] + RL + IL); return self

    def angular(self, NI='', AL=[], IA=[]):
        if np.all(NI!=None) and np.all(NI!=''):
            AL = list(AL)
            IA = list(IA)
            if NI != len(AL) and NI != len(IA):
                raise ValueError('Inconsistent definition. NI is not equal to lengths of AL or IA')
        super().assign_keyword('ANGULAR', [1, NI, NI], [NI,] + AL + IA); return self

    def print(self, prt=''):
        super().assign_keyword('PRINT', [], prt); return self

    def printout(self, prt=''):
        super().assign_keyword('PRINTOUT', [], prt); return self

    def tolldens(self, ID=''):
        super().assign_keyword('TOLLDENS', [1,], ID); return self

    def tollgrid(self, IG=''):
        super().assign_keyword('TOLLGRID', [1,], IG); return self


class ADFT(EDFT):
    """
    ADFT sub-block
    """
    def __init__(self):
        bg = 'ADFT\n'
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'BECKE'    : [None, False, []],
            'SAVIN'    : [None, False, []],
            'RADIAL'   : [None, False, []],
            'ANGULAR'  : [None, False, []],
            'PRINT'    : [None, False, []],
            'PRINTOUT' : [None, False, []],
            'TOLLDENS' : [None, False, []],
            'TOLLGRID' : [None, False, []],
            'NEWBASIS' : ['_newbasis', True, [], 'io._crystalBASE.BasisSet()'],
        }
        self = BlockBASE(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    @property
    def newbasis(self):
        """
        Subblock object NEWBASIS
        """
        self._newbasis._block_valid = True
        self._newbasis._block_bg = 'NEWBASIS\n'
        self._newbasis._block_ed = 'END\n'
        return self._newbasis


class Grid2D(BlockBASE):
    """
    A base class for 2D data grid (ECHG, POTM, CLAS).

    Args:
        header (str): Formatted headers
    """
    def __init__(self, header=''):
        bg = header
        ed = 'END\n'
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'COORDINA' : [None, False, ['COORDINA', 'ATOMS']],
            'ATOMS'    : [None, False, ['COORDINA', 'ATOMS']],
            'RECTANGU' : [None, False, []],
            'MARGINS'  : [None, False, []],
            'PRINT'    : [None, False, []],
            'ANGSTROM' : [None, False, []],
            'BOHR'     : [None, False, []],
            'FRACTION' : [None, False, []],
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    # __call__ method inherited from BlockBASE

    def coordina(self, crda='', crdb='', crdc=''):
        if np.all(crda==None) or np.all(crda==''):
            shape = []
            value = crda
        else:
            shape = [1, 1, 1]
            value = [''.join('{:< 10.6f}'.format(i) for i in crda),
                     ''.join('{:< 10.6f}'.format(i) for i in crdb),
                     ''.join('{:< 10.6f}'.format(i) for i in crdc)]
        super().assign_keyword('COORDINA', shape, value); return self

    def atoms(self, IA='', IB='', IC=''):
        """
        IA IB IC are 4\*1 lists
        """
        super().assign_keyword('ATOMS', [4, 4, 4], [IA, IB, IC]); return self

    def rectangu(self, rec=''):
        super().assign_keyword('RECTANGU', [], rec); return self

    def margins(self, ABM='', CDM='', ADM='', BCM=''):
        super().assign_keyword('MARGINS', [4,], [ABM, CDM, ADM, BCM]); return self

    def print(self, prt=''):
        super().assign_keyword('PRINT', [], prt); return self

    def angstrom(self, ang=''):
        super().assign_keyword('ANGSTROM', [], ang); return self

    def bohr(self, br=''):
        super().assign_keyword('BOHR', [], br); return self

    def fraction(self, frac=''):
        super().assign_keyword('FRACTION', [], frac); return self


class ECHG(Grid2D):
    """
    Class for ECHG. Initialization can be done by formatted string only.
    Otherwise call this object from upper block.

    Args:
        IDER (int): Order of the derivative
        NPY (int): Number of points (MAPNET)
    """
    def __call__(self, IDER='', NPY=100):
        if type(IDER) == str:
            super().__init__('ECHG\n')
            if np.all(IDER!=''):
                self.analyze_text(IDER)
        elif np.all(IDER==None):
            super().__init__('ECHG\n')
            self._block_valid = False
        elif type(IDER) == type(self):
            self = IDER
        elif type(IDER) == int: # valid data
            self.__init__('ECHG\n{}\n{}\n'.format(IDER, NPY))
        else:
            raise ValueError('Unknown input type')


class POTM(Grid2D):
    """
    Class for POTM. Initialization can be done by formatted string only.
    Otherwise call this object from upper block.

    Args:
        IDER (int): Order of the derivative
        ITOL (int): Penetration tolerance
        NPY (int): Number of points (MAPNET)
    """
    def __call__(self, IDER='', ITOL=5, NPY=100):
        if type(IDER) == str:
            super().__init__('POTM\n')
            if np.all(IDER!=''):
                self.analyze_text(IDER)
        elif np.all(IDER==None):
            super().__init__('POTM\n')
            self._block_valid = False
        elif type(IDER) == type(self):
            self = IDER
        elif type(IDER) == int: # valid data
            super().__init__('POTM\n{}{:4d}\n{}\n'.format(IDER, ITOL, NPY))
        else:
            raise ValueError('Unknown input type')


class CLAS(Grid2D):
    """
    Class for CLAS. Initialization can be done by formatted string only.
    Otherwise call this object from upper block.

    Args:
        IDER (int): Order of the derivative
        IFOR (int): Number of point multipoles
        charge (list): Formal net charge
        NPY (int): Number of points (MAPNET)
    """
    def __call__(self, IDER='', IFOR='', charge=[], NPY=100):
        if type(IDER) == str:
            super().__init__('CLAS\n')
            if np.all(IDER!=''):
                self.analyze_text(IDER)
        elif np.all(IDER==None):
            super().__init__('CLAS\n')
            self._block_valid = False
        elif type(IDER) == type(self):
            self = IDER
        elif type(IDER) == int: # valid data
            if IFOR == 0:
                super().__init__('CLAS\n{:<2d}{:2d}\n{}\n'.format(IDER, IFOR, NPY))
            elif IFOR == 1:
                string = ''.join('{:<10.6f} '.format(i) for i in charge)
                super().__init__('CLAS\n{:<2d}{:2d}\n{}\n{}\n'.format(IDER, IFOR, string, NPY))
            else:
                raise ValueError('Unknon IFOR value. Check your input.')
        else:
            raise ValueError('Unknown input type')


class Grid3DBASE(BlockBASE):
    """
    A base class for 3D data grid (ECH3, POT3). Not for 'GRID3D' keyword

    Args:
        header (str): Formatted headers
    """
    def __init__(self, header=''):
        bg = header
        ed = ''
        # The sequence of keywords should follow rules in the manual
        # Read inputbase.py for the definition of dict values
        dic = {
            'RANGE' : [None, False, ['RANGE', 'SCALE']],
            'SCALE' : [None, False, ['RANGE', 'SCALE']],
        }
        super().__init__(bg, ed, '\n', '\n', dic)

    def scale(self, scale1='', scale2='', scale3=''):
        if np.all(scale1=='') or np.all(scale1==None): # others
            super().assign_keyword('SCALE', [], scale1)
        elif np.all(scale2==''): # 2D
            super().assign_keyword('SCALE', [1,], scale1)
        elif np.all(scale3==''): # 1D
            super().assign_keyword('SCALE', [2,], [scale1, scale2])
        else: # 0D
            super().assign_keyword('SCALE', [3,], [scale1, scale2, scale3])
        return self

    def range(self, rg1='', rg2='', rg3=''):
        """
        Inputs are 2\*1 lists. ``[minvalue, maxvalue]``. The sequence of rg123
        is consistent with CRYSTAL (2D: z; 1D: y, z; 0D: x, y, z)
        """
        if np.all(rg1=='') or np.all(rg1==None): # others
            super().assign_keyword('RANGE', [], rg1)
        elif np.all(rg2==''): # 2D
            super().assign_keyword('RANGE', [1, 1], [rg1[0], rg1[1]])
        elif np.all(rg3==''): # 1D
            super().assign_keyword('RANGE', [2, 2], [rg1[0], rg2[0], rg1[1], rg2[1]])
        else: # 0D
            super().assign_keyword('RANGE', [3, 3], [rg1[0], rg2[0], rg3[0], rg1[1], rg2[1], rg3[1]])
        return self


class ECH3(Grid3DBASE):
    """
    Class for ECH3. Initialization can be done by formatted string only.
    Otherwise call this object from upper block.

    Args:
        NP (int): Number of points along the first direction
    """
    def __call__(self, NP=''):
        if type(NP) == str:
            super().__init__('ECH3\n')
            if np.all(NP!=''):
                self.analyze_text(NP)
        elif np.all(NP==None):
            super().__init__('ECH3\n')
            self._block_valid = False
        elif type(NP) == type(self):
            self = NP
        elif type(NP) == int: # valid data
            super().__init__('ECH3\n{}\n'.format(NP))
        else:
            raise ValueError('Unknown input type')


class POT3(Grid3DBASE):
    """
    Class for POT3. Initialization can be done by formatted string only.
    Otherwise call this object from upper block.

    Args:
        NP (int): Number of points along the first direction
        ITOL (int): Penetration tolerance
    """
    def __call__(self, NP='', ITOL=5):
        if type(NP) == str:
            super().__init__('POT3\n')
            if np.all(NP!=''):
                self.analyze_text(NP)
        elif np.all(NP==None):
            super().__init__('POT3\n')
            self._block_valid = False
        elif type(NP) == type(self):
            self = NP
        elif type(NP) == int: # valid data
            super().__init__('POT3\n{}{:4d}\n'.format(NP, ITOL))
        else:
            raise ValueError('Unknown input type')

# --------------------------- crystal output ---------------------------------#

class GeomBASE():
    """A container of basic methods for SCF geometry."""
    @classmethod
    def read_geom(cls, data):
        """
        Read lattice from 'A B C ALPHA BETA GAMMA' block, periodic boundary
        condition and atom positions from 'ATOMS IN THE ASYMMETRIC UNIT'
        block. It terminates at the first empty line after that block.

        Args:
            data (DataFrame): Pandas DataFrame of the output

        Returns:
            struc (CStructure): Extended Pymatgen Structure
        """
        import pandas as pd
        import re
        from pymatgen.core.lattice import Lattice
        from CRYSTALpytools.geometry import CStructure

        pbc = {0 : (False, False, False),
               1 : (True, False, False),
               2 : (True, True, False),
               3 : (True, True, True)}

        species = []
        coords = []
        latt_mx = np.eye(3)

        empty_line = data[data.map(lambda x: x.strip() == '')].index.to_numpy(dtype=int)
        title_line = data[
            data.str.contains(r'^\s+A\s+B\s+C\s+ALPHA\s+BETA\s+GAMMA\s+$')
        ].index.to_numpy(dtype=int)

        # lattice
        if len(title_line) != 0:
            latt_line = np.array(data.loc[title_line[0]+1].strip().split(), dtype=float)
            ndimen = 3 - len(re.findall('\(ANGSTROM\)', data[title_line[0]+4]))
            latt = Lattice.from_parameters(a=latt_line[0], b=latt_line[1],
                                           c=latt_line[2], alpha=latt_line[3],
                                           beta=latt_line[4], gamma=latt_line[5])
            pbc = pbc[ndimen]
        else: # molecules
            latt = Lattice(np.eye(3)*500)
            ndimen = 0
            pbc = (False, False, False)
        latt_mx = latt.matrix

        # Atom coordinates
        atom_line = data[
            data.str.contains(r'^\s*ATOMS IN THE ASYMMETRIC UNIT')
        ].index.to_numpy(dtype=int)

        bg = atom_line[0]
        ed = empty_line[np.where(empty_line>bg)[0][0]]

        coord_list = data.loc[bg+3:ed-1].map(lambda x: x.strip().split()).tolist()
        if len(coord_list) == 0: raise Exception('Geometry information not found.')

        species = [i[2] for i in coord_list] # use conventional atomic numbers
        coords = [i[4:7] for i in coord_list]
        species = np.array(species, dtype=int)
        coords = np.array(coords, dtype=float)

        if ndimen != 0: # to cartesian coords
            coords[:, 0:ndimen] = coords[:, 0:ndimen] @ latt_mx[0:ndimen, 0:ndimen]

        struc = CStructure(lattice=latt, species=species, coords=coords,
                           coords_are_cartesian=True, pbc=pbc)
        return struc


class SCFBASE():
    """A container of basic methods for SCF loop."""
    @classmethod
    def get_SCF_blocks(cls, data):
        """
        Get SCF convergence block from output file.

        Args:
            data (DataFrame): Pandas DataFrame of the output.

        Returns:
            nSCF (int): Number of SCF blocks
            SCFrange (array[int, int]): The beginning and ending points of every
                SCF block.
        """
        scftitle = data[data.str.contains(r'^\s*T+\s+SDIK\s+TELAPSE')].index.to_numpy(dtype=int)
        scfend = data[data.str.contains(r'^\s*== SCF ENDED')].index.to_numpy(dtype=int)
        # This pattern excludes the initial charge assignment but charge info is not always printed out
        realtitle = data[data.str.contains(r'^\s*T+\s+MOQGAD\s+TELAPSE')].index.to_numpy(dtype=int)
        if len(realtitle) == 0:
            raise Exception('SCF block not found. Does it include SCF results?')

        nSCF = len(scftitle)
        SCFrange = np.zeros([nSCF, 2], dtype=int)

        if len(scfend) < len(scftitle):
            scfend.append(len(data)-1)
        for i in range(nSCF):
            SCFrange[i, 0] = realtitle[np.where(realtitle>scftitle[i])[0][0]]
            SCFrange[i, 1] = scfend[i]

        return nSCF, SCFrange

    @classmethod
    def read_convergence(cls, data):
        """
        Read a SCF convergence block.

        Args:
            data (DataFrame): Pandas DataFrame of the SCF convergence block.

        Returns:
            ncyc (int): Number of cycles
            endflag (str): 'terminated', 'converged', 'too many cycles' and 'unknown'
            e (array): nCYC\*1 array of SCF energy. Unit: eV
            de (array): nCYC\*1 array of SCF energy difference. Unit: eV
            spin (bool): Whether the system is spin-polarised.
            efermi (array): Fermi energy. Unit: eV
            gap (array): Band gap. Unit: eV
        """
        # ending lines
        scfend = data[data.str.contains(r'^\s*== SCF ENDED')].index
        if len(scfend) < 1:
            endflag = 'terminated'
            warn('SCF convergence not achieved or missing.', stacklevel=3)
        elif len(scfend) > 1:
            raise ValueError("The 'read_convergence' method only accepts 1 SCF convergence block. Multiple are found.")
        else:
            if 'CONVERGENCE' in data[scfend[0]]:
                endflag = 'converged'
            elif 'TOO MANY CYCLES' in data[scfend[0]]:
                endflag = 'too many cycles'
                warn('SCF convergence not achieved or missing.', stacklevel=3)
            else:
                warn('Unknown termination: {}.'.format(data[scfend[0]]), stacklevel=3)
                endflag = 'unknown'

        stepbg = data[data.str.contains(r'^\s*CHARGE NORMALIZATION FACTOR')].index.to_numpy(dtype=int)
        steped = deepcopy(stepbg[1:])
        ncyc = len(stepbg)

        # energies
        energies = data[data.str.contains(r'\s*CYC\s+[0-9]+\s+ETOT\(AU\)')].index
        e = data[energies].map(lambda x: x.strip().split()[3]).to_numpy(dtype=float)
        de = data[energies].map(lambda x: x.strip().split()[5]).to_numpy(dtype=float)
        ## set the first digit to 0 rather than total energy
        de[0] = 0.
        e = units.H_to_eV(e); de = units.H_to_eV(de)

        # spin
        spinflag = data[data.str.contains(r'^\s*SUMMED SPIN DENSITY')].index
        if len(spinflag) > 0: spin = True
        else: spin = False

        # Fermi level and gap
        efermi = [0.,]
        if spin == False: gap = [0.,]
        else: gap = [[0., 0.]]
        for bg, ed in zip(stepbg[:-1], steped): # Step 0 has no Fermi and gap
            datamini = data.loc[bg:ed]
            condu = datamini[datamini.str.contains(r'^\s*POSSIBLY CONDUCTING STATE - EFERMI')].index.tolist()
            insul = datamini[datamini.str.contains(r'^\s*TOP OF VALENCE BANDS')].index.tolist()
            gapline = datamini[datamini.str.contains(r'^\s*.*DIRECT ENERGY BAND GAP')].index.tolist()
            # spinlock
            if len(condu) == 0 and len(insul) == 0:
                efermi.append(0.)
                if spin == False: gap.append(0.)
                else: gap.append([0., 0.])
            # conductor
            elif len(condu) > 0 and len(insul) == 0:
                efermi.append(float(datamini[condu[0]].strip().split()[5]))
                if spin == False: gap.append(0.)
                else: gap.append([0., 0.])
            # insulator
            elif len(insul) > 0 and len(condu) == 0:
                allfermi = datamini[insul].map(lambda x: x.strip().split()[10]).to_numpy(dtype=float)
                allgap = datamini[gapline].map(lambda x: x.strip().split()[4]).to_numpy(dtype=float)
                efermi.append(np.max(allfermi))
                if spin == False:
                    gap.append(np.min(allgap))
                else:
                    gstate = int(len(allgap) / 2)
                    gap.append([np.min(allgap[:gstate]), np.min(allgap[gstate:])])

        efermi = units.H_to_eV(np.array(efermi, dtype=float))
        gap = np.array(gap, dtype=float)
        return ncyc, endflag, e, de, spin, efermi, gap


class OptBASE():
    """A container of basic methods for Opt loop."""
    @classmethod
    def get_opt_block(cls, data):
        """
        Get optimization convergence block (every OPT step) from output file.

        Args:
            data (DataFrame): Pandas DataFrame of the output.

        Returns:
            nOPT (int): Number of OPT steps
            OPTrange (array[int, int]): The beginning and ending points of every
                OPT step.
            endflag (str): 'terminated', 'converged', 'failed' and 'unknown'
        """
        opttitle = data[data.str.contains(r'^\s*[A-Z]+ OPTIMIZATION - POINT')].index.to_numpy(dtype=int)
        optend = data[data.str.contains(r'^\s*T+ OPTI\s+TELAPSE')].index.to_numpy(dtype=int)
        block_end = data[data.str.contains(r'^\s*\* OPT END')].index.to_numpy(dtype=int)
        # Include initial SCF step
        # opttitle: step 1 to final run
        # optend: initial SCF to last before final run
        if len(opttitle) == 0: raise Exception('Not an optimization output.')
        if len(opttitle) == 1 and len(block_end) == 0: raise Exception('Initial SCF failed. Nothing to extract.')
        # terminated
        if len(block_end) == 0:
            warn('Job interrupted. Not a complete file.', stacklevel=3)
            block_end = np.array([data.index[-1]], dtype=int)
            endflag = 'terminated'
        # normal
        else:
            if 'CONVERGED' in data.loc[block_end[0]]:
                endflag = 'converged'
            elif 'FAILED' in data.loc[block_end[0]]:
                endflag = 'failed'
                warn('Convergence not achieved.', stacklevel=3)
            else:
                warn('Unknown termination: {}.'.format(data.loc[block_end[0]]), stacklevel=3)
                endflag = 'unknown'
        ## get ranges
        nOPT = len(opttitle)
        OPTrange = np.zeros([nOPT, 2], dtype=int)
        OPTrange[:, 0] = opttitle
        OPTrange[-1, 1] = block_end[0]
        if nOPT > 1:
            OPTrange[:-1, 1] = optend
        return nOPT, OPTrange, endflag

    @classmethod
    def read_opt_block(cls, data):
        """
        Read information of every OPT step from output file.

        Args:
            data (DataFrame): Pandas DataFrame of the output.

        Returns:
            e (float): Final SCF energy with corrections. Unit: eV
            de (float): Final SCF energy difference with last OPT step. Unit: eV
            struc (CStructure): Modified pymatgen structure.
            maxg (float): Max energy gradient convergence. Unit: Hartree / Bohr.
            rmsg (float): RMS energy gradient convergence. Unit: Hartree / Bohr,
            maxd (float): Max displacement convergence. Unit: Bohr.
            rmsd (float): RMS displacement convergence. Unit: Bohr.
        """
        eline = data[data.str.contains(r'^\s+TOTAL ENERGY\(DFT\)\(AU\)\(')].index.to_numpy(dtype=int)
        line = data.loc[eline[-1]].strip().split()
        e = units.H_to_eV(float(line[3]))
        gxline = data[data.str.contains(r'^\s+MAX GRADIENT')].index.to_numpy(dtype=int)
        gmline = data[data.str.contains(r'^\s+RMS GRADIENT')].index.to_numpy(dtype=int)
        maxg = float(data.loc[gxline[-1]].strip().split()[2])
        rmsg = float(data.loc[gmline[-1]].strip().split()[2])

        if 'POINT    1' in data.iloc[0]: # initial step, no structure / displacement
            de = 0.
            struc = None
            maxd = 0.
            rmsd = 0.
        else:
            de = units.H_to_eV(float(line[6]))
            struc = GeomBASE.read_geom(data)
            dxline = data[data.str.contains(r'^\s+MAX DISPLAC\.')].index.to_numpy(dtype=int)
            dmline = data[data.str.contains(r'^\s+RMS DISPLAC\.')].index.to_numpy(dtype=int)
            maxd = float(data.loc[dxline[-1]].strip().split()[2])
            rmsd = float(data.loc[dmline[-1]].strip().split()[2])
        return e, de, struc, maxg, rmsg, maxd, rmsd

# --------------------------- properties output ------------------------------#

class POutBASE():
    """
    Base object for Properties output file. Auxiliary information is
    extracted. Other data is read from formatted files respectively.

    Args:
        filename (str): Properties output file name.
    """
    def __init__(self, filename):
        try:
            file = open(filename, 'r', errors='ignore')
            self.data = file.readlines()
            file.close()
        except:
            raise FileNotFoundError('EXITING: an output file needs to be specified')

    def get_geometry(self):
        """
        Get geometry from properties output calculation.

        Returns:
            struc (CStructure): Modified Pymatgen structure
        """
        import re
        from pymatgen.core.lattice import Lattice
        from CRYSTALpytools.geometry import CStructure

        data = self.data
        countline = 0
        lattice = []
        cart_coord = []
        species = []
        ndimen = 0
        while countline < len(data):
            line = data[countline]
            if re.match(r'^\s+DIRECT LATTICE VECTOR COMPONENTS', line):
                lattice = [data[countline+1].strip().split(),
                           data[countline+2].strip().split(),
                           data[countline+3].strip().split()]
                countline += 4
                continue
            # get dimension, for 1-3D
            elif re.match(r'^\s+A\s+B\s+C\s+ALPHA\s+BETA\s+GAMMA\s+VOLUME', line):
                countline += 1
                line = data[countline].strip().split()
                [a, b, c, al, be, ga, vol] = [float(i) for i in line]
                s = a * b * np.sin(ga/180*np.pi)
                l = a
                if np.abs(vol-l) < 1e-4:
                    ndimen = 1
                elif np.abs(vol-s) < 1e-4:
                    ndimen = 2
                else:
                    ndimen = 3
            elif re.match(r'^\s+ATOM N\.AT\.\s+SHELL\s+X\(A\)', line):
                countline += 2
                line = data[countline]
                while not re.match(r'^\s*\*+\s*$', line):
                    line_data = line.strip().split()
                    species.append(line_data[1])
                    cart_coord.append(line_data[4:7])
                    countline += 1
                    line = data[countline]

                break
            else:
                countline += 1
                continue

        if len(cart_coord) == 0:
            raise Exception('Valid geometry not found.')

        pbc = {0 : (False, False, False),
               1 : (True, False, False),
               2 : (True, True, False),
               3 : (True, True, True)}
        if ndimen > 0:
            lattice = Lattice(np.array(lattice, dtype=float), pbc=pbc[ndimen])
        else:
            lattice = Lattice(np.eye(3)*500., pbc=(False, False, False))
        species = [int(i) for i in species]
        cart_coord = np.array(cart_coord, dtype=float)
        return CStructure(lattice=lattice, species=species, coords=cart_coord,
                          coords_are_cartesian=True)

    def get_lattice(self):
        """
        Get lattice matrix from properties output calculation. A 3D lattice is
        generated since no dimensionality information is provided.

        Returns:
            matrix (array): 3\*3 lattice matrix
        """
        struc = self.get_geometry()
        return struc.lattice.matrix

    def get_topond_geometry(self):
        """
        Get the cluster geometry and plot plane base (2D only) from TOPOND
        calculation output.

        Returns:
            atomsplt (array): Atomic numbers and coordinates in plotting frame.
            base (array): *Valid for 2D plots only* 3\*3 range of orthogonal
                plotting base x and y. A: (xmin, ymax), B: (xmin, ymin), C:
                (xmax, ymin). Unit: Bohr.
        """
        import re
        from CRYSTALpytools.units import angstrom_to_au
        from scipy.spatial.transform import Rotation

        data = self.data
        countline = 0
        istopond = False; atomsplt = []; rotmx = []; xyrange = [];
        while countline < len(data):
            line = data[countline]
            if re.match(r'^\s*\*\s+T O P O N D', line):
                istopond = True
                countline += 1
            elif re.match(r'^\s*\*\*\* ATOMS \(POINTS\)\: AT\. N\. AND TRASFORMED COORD\.\(AU\)',
                          line):
                countline += 2
                line = data[countline]
                while line.strip() != '':
                    atomsplt.append(line.strip().split())
                    countline += 1
                    line = data[countline]
            elif re.match(r'^\s*ROTAT\. MATRIX', line):
                for i in range(3):
                    line = data[countline+i]
                    rotmx.append(line[37:].strip().split()[0:3])
                countline += 3
            elif re.match(r'^\s*ORIGIN AT \( AU\; SYSTEM REF\. FRAME\)', line):
                origin = line[37:].strip().split()[0:3]
                origin = np.array(origin, dtype=float)
                countline += 1
            elif re.match(r'^\s*X AXIS RANGES AND INCREMENTS', line):
                xyrange.append(line[37:].strip().split()[0:3])
                countline += 1
                line = data[countline]
                xyrange.append(line[37:].strip().split()[0:3])
                xyrange = np.array(xyrange, dtype=float)
                if '(ANG)' in line:
                    xyrange = angstrom_to_au(xyrange)
                break
            else:
                countline += 1

        if istopond == False:
            raise Exception("TOPOND output not found. Is it a TOPOND output file?")

        atomsplt = np.array(atomsplt, dtype=float)
        # define rotation
        rotmx = np.array(rotmx, dtype=float)
        rot = Rotation.from_matrix(rotmx)
        originplt = rot.apply(origin)
        # force origin to 0
        baseplt = np.vstack([originplt, originplt, originplt])
        baseplt[0, 0:2] += [xyrange[0, 0], xyrange[1, 1]]
        baseplt[1, 0:2] += [xyrange[0, 0], xyrange[1, 0]]
        baseplt[2, 0:2] += [xyrange[0, 1], xyrange[1, 0]]
        base = rot.inv().apply(baseplt)

        return atomsplt, base

    def get_reciprocal_lattice(self):
        """
        Get reciprocal lattice matrix from properties output calculation. A 3D
        lattice is generated since no dimensionality information is provided.

        Returns:
            matrix (array): 3\*3 reciprocal lattice matrix
        """
        struc = self.get_geometry()
        return struc.lattice.reciprocal_lattice.matrix

    def get_3dkcoord(self):
        """
        BANDS calculation only. Get 3D fractional coordinates of high-symmetry
        and sampled k points from output file.

        Returns:
            tick_pos3d (array): ntick\*3 array of fractional coordinates of
                high symmetry k points
            k_pos3d(array): nkpoint\*3 fractional coordinates of k points
        """
        import re

        data = self.data
        is_band = False
        tick_pos3d = []
        k_pos3d = np.array([np.nan, np.nan, np.nan], dtype=float)
        for nline, line in enumerate(data):
            if re.match(r'^\s*\*\s+BAND STRUCTURE\s+\*$', line):
                is_band = True
            elif re.match(r'^\s*LINE\s+[0-9]+\s+\(', line):
                bg = np.array(line[10:25].strip().split(), dtype=float)
                ed = np.array(line[26:41].strip().split(), dtype=float)
                if len(tick_pos3d) > 0:
                    # do not repeat the same point in the middle
                    if np.array_equal(tick_pos3d[-1], bg):
                        tick_pos3d.append(ed)
                    else:
                        tick_pos3d.append(bg)
                        tick_pos3d.append(ed)
                else:
                    tick_pos3d.append(bg)
                    tick_pos3d.append(ed)
            elif re.match(r'^\s*[0-9]+ POINTS \- SHRINKING', line):
                nkp = int(line.strip().split()[0])
                kpos = np.concatenate([np.linspace(bg[0], ed[0], nkp),
                                       np.linspace(bg[1], ed[1], nkp),
                                       np.linspace(bg[2], ed[2], nkp)])
                kpos = np.reshape(kpos, [3, nkp], order='C')
                k_pos3d = np.vstack([k_pos3d, kpos.transpose()])
            elif re.match(r'^\s*[0-9]+ DATA WRITTEN ON UNIT 25', line):
                break

        if is_band == False:
            raise Exception('Not a valid band calculation.')

        tick_pos3d = np.array(tick_pos3d)
        k_pos3d = k_pos3d[1:, :]

        return tick_pos3d, k_pos3d

    def get_XRDSPEC(self):
        """
        The keyword 'XRDSPEC' only. Get calculated XRD spectra.
        """
        import pandas as pd

        df = pd.DataFrame(self.data)
        title = df[df[0].str.contains(r'^\s+XRD SPECTRUM\s+$')].index
        if len(title) == 0: raise Exception("XRD spectra not found in file.")

        end = df[df[0].str.contains(r'^\s*T+ XRDSPEC\s+TELAPSE')].index
        if len(end) == 0: raise Exception("Abnormal termination. XRD spectra output broken.")

        spec = df[0][title[0]+7 : end[0]].map(lambda x: x.strip().split()).tolist()
        spec = np.array(spec, dtype=float)
        return spec

    def get_Fermi(self):
        """
        Get Fermi energy in eV from the common block.
        """
        import pandas as pd

        df = pd.DataFrame(self.data)
        fline = df[df[0].str.contains(r'^\s*N\. OF SCF CYCLES.+FERMI ENERGY')].index[0]
        return units.H_to_eV(float(df[0].loc[fline].strip().split()[-1]))
