#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
A post-processing module for DFT lattice dynamics by harmonic and quasiharmonic
approximations (HA/QHA).
"""
from warnings import warn, filterwarnings
from copy import deepcopy

from numpy.polynomial.polynomial import Polynomial, polyfit
import numpy as np
from scipy.constants import N_A as Avogadro
from scipy.constants import h as Planck
from scipy.constants import k as Boltzmann
from scipy.optimize import least_squares, minimize, linear_sum_assignment
from sympy import diff, lambdify, symbols

from CRYSTALpytools.base.dump import ThermoHA, ThermoQHA
from CRYSTALpytools import units
from CRYSTALpytools.phonons import Phonon

molh = Planck * Avogadro
molk = Boltzmann * Avogadro
molpv = Avogadro * 1e-24 # kJ/mol


class Harmonic():
    """
    A class for harmonic phonon calclulations. It can be parameterized from a
    CRYSTAL output file, phonopy ouput file or by setting all the information
    (usually for QHA).

    Args:
        temperature (array|float): *Optional* Temperatures where thermodynamic
            properties are computed. Unit: K
        pressure (array|float): *Optional* Pressures where thermodyanmic
            properties are calculated. Unit: GPa
        filename (str | None): Name of the printed-out file. If None, do not
            print out file.
        autocalc (bool): Automatically launch calculations.
        use_old (bool): Use the deprecated text fomat output, which cannot be
            used for restarting calculation.

    Temperatures and pressures can also be defined by ``self.thermodynamics``,
    whose entries always cover the entries here.

    Phonon dispersions are forced to be summed if the automatic scheme
    (``autocalc=True``) is launched. To get verbose outputs, call
    ``self.thermodynamics()`` first and then call ``self.print_results()``.

    Usage::

        ha = Harmonic(temperature=[0, 100, 200, 300], pressure=[0.,])
        ha.from_file('harmonic_phonon.out')
    """

    def __init__(self, temperature=[], pressure=[], filename=None,
                 autocalc=True, use_old=False):
        self.temperature = np.array(temperature, dtype=float, ndmin=1)
        self.pressure = np.array(pressure, dtype=float, ndmin=1)
        self.autocalc = autocalc
        self.filename = str(filename)
        if self.filename != 'None':
            if use_old == True:
                warn('The text output is deprecated. Please use the dumping file in YAML format.', stacklevel=2)
                self.filefmt = 'txt'
            else:
                self.filefmt = 'yaml'
        else:
            self.filefmt = 'None'

    @property
    def edft(self):
        """For compatibility"""
        return self.u_0

    @classmethod
    def restart(cls, filename):
        """
        Restart calculation from a dumped YAML file. ``autocalc`` is switched
        off. Instantiation will not update the dumped file, but thermodynamic
        calculations will.

        Args:
            filename (str): YAML file
        Returns:
            obj (Harmonic)
        """
        obj = ThermoHA.restart(filename)
        obj.filename = filename
        obj.filefmt = 'yaml'
        return obj

    def from_file(self, filename, source='crystal',
                  scale=1.0, scale_range=[],
                  imaginary_tol=-1e-4, q_overlap_tol=1e-4,
                  q_id=None, q_coord=None, read_eigvt=False, **kwargs):
        """
        Generate the Harominc object from an output file. Files generated by
        the following methods are supported (also the accepted entries for
        ``source``):

        * ``'crystal'``: CRYSTAL harmonic phonon outputs (Gamma, dispersion).  
        * ``'crystal-QHA'``: CRYSTAL QHA outputs.  
        * ``'phonopy'``: Phonopy qpoints and mesh files.

        .. note::

            In rare cases, the user might want to collect data of a few
            specific q points. ``q_id`` and ``q_coord`` can be set but not
            simultaneously. If set, ``q_id`` takes priority and ``q_coord`` is
            ignored.

        Args:
            filename (str): Name of the output file.
            source (str): The program used for the output file.
            scale (float|array): Scaling factors
            scale_range (array): nScale\*2 array. The frequency range of the
                scaling factor. Including the minimum and excluding the maximum.
                Use empty list for a uniform scaling.
            imaginary_tol (float): The threshold of negative frequencies.
            q_overlap_tol (float): The threshold of overlapping points, defined
                as the 2nd norm of the difference of fractional q vectors
            q_id (array): Index (from 0) of q points to be read. 1\*nqpoint.
            q_coord (array): Fractional coordinates of q points to read.
                nqpoint\*3 list.
            read_eigvt: Deprecated.
            \*\*kwargs: Other keywords passed to corresponding I/O functions.
                See below.
            qha_index (int): *crystal-QHA*. The index of calculation to read (from 0).
            struc_yaml (str): *phonopy*. 'qpoints.yaml' only.
            u_0 (float): *phonopy*. Static internal energy in kJ/mol.

        Returns:
            self (Harmonic): Attributes listed below.
            structure (CStructure): Extended Pymatgen structure class. For
                the finite displacement method, this is the cell before
                supercell expansion.
            natom (int): Number of atoms in the cell.
            volume (float): Volume of the cell. Unit: :math:`\\AA^{3}`
            u_0 (float): Internal energy. Unit: kJ/mol
            nqpoint (int): Number of q points
            qpoint (list): nQpoint\*4 list. The first three elements are 
                fractional coordinates in reciprocal space and the last is
                its weight, i.e., number of equivalent q points.
            nmode (int): Number of modes.
            frequency (array[float]): nQpoint\*nMode array of frequencies in THz.
            mode_symm (array[str]): nQpoint\*nMode array of the  irreducible
                representations. In Mulliken symbols.
            eigenvector (array[float]): nQpoint\*nMode\*nAtom\*3 array of phonon
                eigenvectors.
        """
        if hasattr(self, "frequency"):
            raise Exception("Data exists. Please start from an empty object.")

        # kJ/mol to eV
        if 'u_0' in kwargs.keys():
            kwargs['u_0'] = units.H_to_eV(units.kjmol_to_H(kwargs['u_0']))

        phonon = Phonon.from_file(filename, source=source,
                                  q_id=q_id, q_coord=q_coord, **kwargs)
        # eV to kJ/mol
        u_0 = units.H_to_kjmol(units.eV_to_H(phonon.u_0))

        phonon.frequency = phonon.scale_frequency(scale, scale_range)
        phonon.clean_q_overlap(threshold=q_overlap_tol)
        phonon.clean_imaginary(threshold=imaginary_tol)
        # Instantiation
        self.from_frequency(u_0, phonon.qpoint, phonon.frequency,
                            phonon.eigenvector, phonon.mode_symm,
                            structure=phonon.structure)
        # Autocalc
        if self.autocalc == True:
            self.thermodynamics()
        else:
            if self.filefmt=='yaml':
                ThermoHA.write(self)
            elif self.filefmt=='txt':
                ThermoHA.old_write(self)
        return self

    def from_frequency(self, u_0, qpoint, frequency, eigenvector, symmetry,
                       structure=None, natom=None, volume=None):
        """
        Generate a Harmonic object by specifying frequency and eigenvector.
        Usually called by other methods.

        Args:
            u_0 (float): Static total energy in kJ/mol.
            qpoint (array[float]): nQpoint\*4 array. The first three elements
                are fractional coordinate and the last is weight.
            frequency (array[float]): Array of frequencies. Unit: THz
            eigenvector (array[float]): Mass weighted and phased eigenvectors
            normalized to 1.
            symmetry (array[str]): Irreducible representations in Mulliken symbols.
            structure (CStructure): Extended Pymatgen structure class. For the
                finite displacement method, this is the cell before expansion.
            natom (int): Number of atoms in the reduced cell.
            volume (float): Volume of the reduced cell. Unit: :math:`\\AA^{3}`.

        .. note::

            The user should define either ``structure`` or ``natom`` + ``volume``.

        Returns:
            self (Harmonic): Attributes see ``from_file()``.

        :raise Exception: If computational data is stored in the object.
        :raise ValueError: If neither of the 2 available options are defined.
        """
        if hasattr(self, "frequency"):
            raise Exception("Data exists. Please start from an empty object.")

        if np.all(structure!=None):
            self.structure = structure
            self.natom = structure.num_sites
            self.volume = structure.lattice.volume
        elif np.all(natom!=None) and np.all(volume!=None):
            self.natom = int(natom)
            self.volume = float(volume)
        else:
            raise ValueError('Geometry is not sufficiently defined. Structure or volume + natom are needed.')

        if len(qpoint) != frequency.shape[0]:
            raise ValueError("The 1st dimension (n qpoint) of 'qpoint' and 'frequency' are not consistent.")
        if symmetry.shape[0] != frequency.shape[0] or symmetry.shape[1] != frequency.shape[1]:
            raise ValueError("Inconsistent dimensions between 'frequency' and 'symmetry'.")
        if eigenvector.shape[-1] != 0:
            if eigenvector.shape[0] != frequency.shape[0] or eigenvector.shape[1] != frequency.shape[1]:
                raise ValueError("Inconsistent dimensions between 'frequency' and 'eigenvector'.")
            if eigenvector.shape[2] != self.natom:
                raise ValueError("The 3rd dimension (n atom) of 'eigenvector' and input geometry are not consistent.")

        self.u_0 = u_0
        self.nqpoint = len(qpoint)
        self.qpoint = qpoint
        self.frequency = np.array(frequency, dtype=float, ndmin=2)
        self.nmode = self.frequency.shape[1]
        self.mode_symm = np.array(symmetry, dtype=str, ndmin=2)
        self.eigenvector = np.array(eigenvector, dtype=complex, ndmin=4)
        return self

    def thermodynamics(self, **kwargs):
        """
        Calculate the thermodynamic properties (zp_energy, u_vib, entropy, c_v
        and Gibbs and Helmholtz free energy) of the HA system.

        Zero-point energy :math:`E^{zp}`:

        .. math::

            E^{zp}=\\sum_{i,\\mathbf{q}}\\frac{1}{2}\\hbar\\omega_{i,\\mathbf{q}}

        Vibration contribution to internal energy :math:`U^{vib}`:

        .. math::

            U^{vib}\\left(T\\right)=E^{zp}+\\sum_{i,\\mathbf{q}}
            \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{\\exp{\\left(
                \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
            \\right)}-1}

        Entropy :math:`S`:

        .. math::

            S\\left(T\\right)=k_{B}\\sum_{i,\\mathbf{q}}\\left\\{
                \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T\\left[
                    \\exp{\\left(
                        \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
                    \\right)}-1
                \\right]}-\\ln{\\left[
                    1-\\exp{\\left(
                        -\\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
                    \\right)}
                \\right]}
            \\right\\}

        Constant volume specific heat :math:`C^{V}`:

        .. math::

            C_{V}\\left(T\\right)=\\sum_{i,\\mathbf{q}}
            \\frac{\\left(\\hbar\\omega_{i,\\mathbf{q}}\\right)^{2}}{k_{B}T^{2}}
            \\frac{\\exp{
            \\left(
                \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
            \\right)}
            }{\\left[
                \\exp{\\left(
                    \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
                \\right)-1}
            \\right]^{2}
            }

        The Helmholtz and Gibbs free energies are defined as:

        .. math::

            F(T) = U_{0} + F_{vib}(T) = U_{0} + U_{vib}(T) - TS(T)

            G(T, p) = F + pV

        Args:
            temperature (array|float): *Optional* Unit: K
            pressure (array|float): *Optional* Unit: GPa
            sumphonon (bool): Deprecated. Not used.

        Returns:
            self (Harmonic): Attributes listed below.
            self.helmholtz (array): 1\*nTemperature. Unit: KJ/mol
            self.gibbs (array): nPressure\*nTemperature. Unit: KJ/mol
            self.zp_energy (float): Zero-point energy. Unit: KJ/mol
            self.u_vib (array): Vibrational contribution to internal energy.
                1\*nTemperature. Unit: KJ/mol
            self.entropy (array): 1\*nTemperature. Unit: J/mol\*K
            self.c_v (array): Constant volume specific heat. 1\*nTemperature.
                Unit: J/mol\*K

        :raise Exception: If temperature and pressure are defined neither here nor during initialization
        """
        # Generate temperature and pressure series
        if 'temperature' in kwargs:
            if len(self.temperature) > 0:
                warn('Temperature attribute exists. Input temperatures will be used to update the attribute.', stacklevel=2)
            self.temperature = np.array(kwargs['temperature'], dtype=float, ndmin=1)

        if 'pressure' in kwargs:
            if len(self.pressure) > 0:
                warn('Pressure attribute exists. Input pressures will be used to update the attribute.', stacklevel=2)
            self.pressure = np.array(kwargs['pressure'], dtype=float, ndmin=1)

        if len(self.temperature)==0 or len(self.pressure)==0:
            raise Exception('Temperature and pressure should be specified.')
        zp_energy = np.zeros([self.nqpoint,], dtype=float)
        u_vib = np.zeros([self.nqpoint, len(self.temperature)], dtype=float)
        entropy = np.zeros([self.nqpoint, len(self.temperature)], dtype=float)
        c_v = np.zeros([self.nqpoint, len(self.temperature)], dtype=float)

        it = np.where(self.temperature>1e-4)[0]
        tempt = self.temperature[it]
        kBT = molk * tempt * 1e-3 # kJ/mol
        for iq in range(self.nqpoint):
            freq = self.frequency[iq, np.where(self.frequency[iq]>1e-4)[0]]
            hbar_freq = freq * molh * 1e9 # kJ/mol
            zp_energy[iq] = 0.5 * np.sum(hbar_freq)

            hbar_freq = np.repeat(hbar_freq[:, np.newaxis], tempt.shape[0], axis=1) # nMode * nT
            beta = hbar_freq / kBT
            exp = np.exp(beta)
            u_vib[iq] += zp_energy[iq]
            u_vib[iq, it] += np.sum(hbar_freq / (exp - 1), axis=0)
            entropy[iq, it] = np.sum(molk * (beta/(1-1/exp) - np.log(exp-1)), axis=0)
            c_v[iq, it] = np.sum(beta**2 * molk / (exp - 2 + 1/exp), axis=0)

        helm = -entropy * self.temperature * 1e-3 + u_vib + self.u_0
        gibbs = np.zeros([self.nqpoint, len(self.pressure), len(self.temperature)], dtype=float)
        for npress, press in enumerate(self.pressure):
            gibbs[:, npress, :] = press * self.volume * molpv + helm

        wt = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])
        # wt = wt.reshape([1, self.nqpoint])
        # self.nqpoint = 1
        # self.qpoint = np.array([[0., 0., 0., 1.]], dtype=float)
        self.zp_energy = wt @ zp_energy
        self.u_vib = wt @ u_vib
        self.entropy = wt @ entropy
        self.c_v = wt @ c_v
        self.helmholtz = wt @ helm
        self.gibbs = np.zeros([len(self.pressure), len(self.temperature)], dtype=float)
        for i in range(len(self.pressure)):
            self.gibbs[i, :] = wt @ gibbs[:,i,:]

        # Deprecated attributes and methods
        if self.filefmt=='yaml':
            filterwarnings("ignore", 'The existing HA file will be overwritten.')
            ThermoHA.write(self)
        elif self.filefmt=='txt':
            ThermoHA.old_write(self)
        return self

    def mode_thermo(self, q, m, **kwargs):
        """Return to thermodynamic properties of the specified mode(s). Units
        are consistent with the ``thermodynamics()`` method.

        Args:
            q (int|array): Indices of q point, from 0.
            m (int|array): Indices of mode, from 0.
            \*\*kwargs: See below.
            temperature (array|float): If not present, use ``self.temperature``. It will not update the attribute.
            pressure (array|float): If not present, use ``self.pressure``. It will not update the attribute.
        Returns:
            zp_energy (float)
            u_vib (array): 1\*nTemperture
            entropy (array): 1\*nTemperture
            c_v (array): 1\*nTemperture
            helmholtz (array): 1\*nTemperture, excluding DFT total energy of the system
            gibbs (array): nPressure\*nTemperture, excluding DFT total energy of the system
        """
        if 'temperature' in kwargs: T = kwargs['temperature']
        else: T = self.temperature
        if 'pressure' in kwargs: p = kwargs['pressure']
        else: p = self.pressure

        if len(T)==0 or len(p)==0:
            raise Exception('Temperature and pressure should be specified.')

        q = np.array(q, dtype=int, ndmin=1)
        m = np.array(m, dtype=int, ndmin=1)
        nT = T.shape[0]; npress = p.shape[0]
        wt = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])

        zp_energy = 0.
        u_vib = np.zeros([nT, ], dtype=float)
        entropy = np.zeros([nT, ], dtype=float)
        c_v = np.zeros([nT, ], dtype=float)
        it = np.where(T>1e-4)[0]
        tempt = T[it]
        kBT = molk * tempt * 1e-3 # kJ/mol
        for iqpt, wqpt in zip(q, wt[q]):
            freq = self.frequency[iqpt, m]
            freq = freq[np.where(freq>1e-4)[0]]
            hbar_freq = freq * molh * 1e9 # kJ/mol
            zp_energy += 0.5 * np.sum(hbar_freq) * wqpt

            hbar_freq = np.repeat(hbar_freq[:, np.newaxis], tempt.shape[0], axis=1) # nMode * nT
            beta = hbar_freq / kBT
            exp = np.exp(beta)
            u_vib[it] += np.sum(hbar_freq / (exp - 1), axis=0) * wqpt
            entropy[it] += np.sum(molk * (beta/(1-1/exp) - np.log(exp-1)), axis=0) * wqpt
            c_v[it] += np.sum(beta**2 * molk / (exp - 2 + 1/exp), axis=0) * wqpt

        u_vib += zp_energy
        helmholtz = -entropy * T * 1e-3 + u_vib
        gibbs = np.zeros([npress, nT], dtype=float)
        for ipress, press in enumerate(p):
            gibbs[ipress, :] = press * self.volume * molpv + helmholtz
        return zp_energy, u_vib, entropy, c_v, helmholtz, gibbs

    def write_HA_result(self):
        if self.filename == 'None':
            warn('Output file not specified. Return.')
            return
        if self.filefmt=='yaml':
            filterwarnings("ignore", 'The existing HA file will be overwritten.')
            ThermoHA.write(self)
        elif self.filefmt=='txt':
            ThermoHA.old_write(self)
        return

# -------------------------------- deprecated --------------------------------#
    def from_phonopy(self, phono_yaml, struc_yaml=None, edft=None, scale=1.0,
                     imaginary_tol=1e-4, q_overlap_tol=1e-4, q_id=None, q_coord=None):
        """ Deprecated. Call ``from_file()`` directly."""
        warn("Deprecated. Call 'from_file(source='phonopy')' instead.", stacklevel=2)
        self.from_file(phono_yaml, source='phonopy', scale=scale,
                       imaginary_tol=imaginary_tol, q_overlap_tol=q_overlap_tol,
                       q_id=q_id, q_coord=q_coord, struc_yaml=struc_yaml, u_0=edft)
        return self


class Quasi_harmonic:
    """
    Generate and rearrange harmonic phonons, store the fitted, volume-dependent
    QHA phonon information and obtain the QHA thermodynamic properties.

    Args:
        temperature (array|float): Unit: K
        pressure (array|float): Unit: GPa
        filename (str): Name of the output file in YAML format for restarting calculation.
        use_old (bool): Use the deprecated text fomat output, which cannot be
            used for restarting calculation.

    Temperatures and pressures can also be defined by ``self.thermodynamics``,
    whose entries always cover the entries here.

    Usage::

        qha = Quasi_harmonic()
        qha.from_QHA_file('qha_phonon.out')
        qha.thermo_freq(eos_method='birch_murnaghan', temperature=[0, 100, 200, 300], pressure=[0., 0.5, 1.]):
    """

    def __init__(self, temperature=[], pressure=[], filename=None, use_old=False):
        self.temperature = np.array(temperature, dtype=float, ndmin=1)
        self.pressure = np.array(pressure, dtype=float, ndmin=1)
        self.filename = str(filename)
        # should be changed by the corresponding method only.
        self.method = 'unknown'
        if self.filename != 'None':
            if use_old == True:
                warn('The text output is deprecated. Please use the dumping file in YAML format.', stacklevel=2)
                self.filefmt = 'txt'
            else:
                self.filefmt = 'yaml'
        else:
            self.filefmt = 'None'

    def from_file(self, *filename, source='crystal', mode_sort_tol=0.4, **kwargs):
        """
        Instatiation from output file(s). Files generated by the following
        methods are supported (also the accepted entries for ``source``):

        * ``'crystal'``: CRYSTAL harmonic phonon outputs (Gamma, dispersion).  
        * ``'crystal-QHA'``: CRYSTAL QHA outputs.  
        * ``'phonopy'``: Phonopy qpoints and mesh files.

        Instatiation from outputs.

        Args:
            \*filename (str): Phonon output filename(s). Extendable.
            source (str): The program used for the output file.
            mode_sort_tol (float | None): The threshold of close mode overlaps
                with eigenvectors if present. If none, do not sort modes and
                eigenvector is not read.
            \*\*kwargs: Optional keywords passed to ``Harmonic().from_file()``.
            scale (float|array):
            scale_range (array):
            imaginary_tol (float):
            q_overlap_tol (float):
            q_id (array): Applied to all HA calculations.
            q_coord (array): Applied to all HA calculations.
            struc_yaml (list[str]): *phonopy*. 'qpoints.yaml' only.
            u_0 (list[float]): *phonopy*. Static internal energy in kJ/mol.

        Returns:
            self (Quasi_harmonic): New Attributes listed below
            ncalc (int): Number of HA phonon calculations.
            combined_volume (array[float]): 1\*nCalc volumes. Unit: :math:`\\AA^{3}`
            combined_u0 (array[float]): 1\*nCalc static internal energies. Unit: kJ/mol
            combined_freq (array[float]): nQpoint\*nMode\*nCalc frequencies. Unit: THz
            combined_symm (array[str]): nQpoint\*nMode\*nCalc mode symmetry in Mulliken symbol.
            nqpoint (int): Number of q points.
            qpoint (array[float]): nQpoint\*4 array. The first three elements are fractional coordinates,
                and the last is the weight.
            nmode (int): Number of modes.
            natom (int): Number of atoms.
        """
        import pandas as pd

        if hasattr(self, "ncalc"):
            Exception("Data exists. Please start from an empty object.")

        # compatibility with older versions.
        if isinstance(filename[0], list) or isinstance(filename[0], np.ndarray):
            filename = filename[0]

        source = source.lower()
        source_list = ['crystal', 'crystal-qha', 'phonopy']
        if source not in source_list:
            raise Exception("Unknown source file: '{}'.".format(source))

        if source == 'crystal-qha':
            if len(filename) != 1: raise Exception("The source 'crystal-QHA' only accepts one input file.")
            file = open(filename[0])
            df = pd.DataFrame(file)
            file.close()
            qhatitle = df[df[0].str.contains(r'\s+QUASI\-HARMONIC APPROXIMATION\s*$')].index
            if len(qhatitle) == 0: raise Exception("Not a CRYSTAL QHA file.")
            dftitle = df[df[0].str.contains(r'\s*\*\s+CELL DEFORMATION\s*$')].index.tolist()
            self.ncalc = len(dftitle); del df
        else:
            self.ncalc = len(filename)

        if self.ncalc == 1:
            raise Exception('Only 1 input file! Use Harmonic object or from_QHA_file method.')

        # Harmonic input arguments
        accepted_args = ['scale', 'scale_range', 'imaginary_tol', 'q_overlap_tol',
                         'q_id', 'q_coord', 'struc_yaml', 'u_0']
        list_args = ['struc_yaml', 'u_0']
        hainp = dict(source=source)
        for a in kwargs.keys():
            if a in accepted_args:
                if a in list_args:
                    array = np.array(kwargs[a])
                    if array.shape[0] != self.ncalc:
                        raise Exception("Input '{}' must have the same dimension as number of calculations.".format(a))
                    hainp[a] = array
                else:
                    hainp[a] = kwargs[a]
        if mode_sort_tol != None: hainp['read_eigvt'] = True
        else: hainp['read_eigvt'] = False

        # Instatiate HA objects.
        ha_list = []
        if source == 'crystal':
            for file in filename:
                ha_list.append(
                    Harmonic(filename=None, autocalc=False).from_file(file, **hainp)
                )
        elif source == 'crystal-qha':
            for icalc in range(self.ncalc):
                hainp['qha_index'] = icalc
                ha_list.append(
                    Harmonic(filename=None, autocalc=False).from_file(filename[0], **hainp)
                )
        elif source == 'phonopy':
            for ifile, file in enumerate(filename):
                realinp = deepcopy(hainp)
                if 'u_0' in hainp.keys(): # kJ/mol
                    realinp['u_0'] = hainp['u_0'][ifile]
                if 'struc_yaml' in hainp.keys():
                    realinp['struc_yaml'] = hainp['struc_yaml'][ifile]
                ha_list.append(
                    Harmonic(filename=None, autocalc=False).from_file(file, **realinp)
                )

        if mode_sort_tol!=None and ha_list[0].eigenvector.shape[-1] != 0:
            close_overlap = self._combine_data(ha_list, mode_sort_tol=mode_sort_tol)
        else:
            _ = self._combine_data(ha_list, mode_sort_tol=None)
            close_overlap = []

        if self.filefmt=='yaml':
            ThermoQHA.write_combine_data(self, close_overlap)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_combine_data(self, close_overlap)
        return self

    @property
    def combined_edft(self):
        """For compatibility with older versions"""
        return self.combined_u0

    @classmethod
    def restart(cls, filename):
        """
        Restart calculation from a dumped YAML file. Instantiation will not
        update the dumped file, but thermodynamic calculations will.

        Args:
            filename (str): YAML file
        Returns:
            obj (Quasi_harmonic)
        """
        obj = ThermoQHA.restart(filename)
        obj.filename = filename
        obj.filefmt = 'yaml'
        return obj

    def thermo_freq(self, eos_method='birch_murnaghan', poly_order=[2, 3],
                    min_method='BFGS', volume_bound=None, mutewarning=False,
                    **kwargs):
        """
        Obtain thermodynamic properties by explicitly fitting phonon
        frequencies as polynomial functions of volume. DFT total energies are
        fitted as a function of volume by equation of states (EOS).

        The equilibrium volume is fitted by minimizing Gibbs free energy at
        constant temperature and pressure.

        .. math::

            V(T,p)=\\text{min}[G(V;T,p)]=\\text{min}[E_{0}(V)+F_{vib}(V;T,p)+pV)]

        Parameterized and tested algorithms for ``min_method``:

        * BFGS(no boundary)  
        * L-BFGS-B(with boundary)

        Isothermal bulk modulus :math:`K_{T}` is obtained by a secondary fit of
        $F(V; T)$ with the same ``eos_method``.

        .. math::

            K_{T}(p;T) = V(p;T)\\left(\\frac{\\partial^{2}F(V;T)}{\\partial V^{2}}\\right)_{T}

        .. note::

            For a good fitting of isothermal bulk modulus :math:`K_{T}`, the
            number of pressures must >= 5.

        Args:
            eos_method (str): EOS used to fit DFT total energy and Helmholtz
                free energy (to get bulk modules). Valid entries are consistent
                with `PyMatGen eos module <https://pymatgen.org/pymatgen.analysis.html#module-pymatgen.analysis.eos>`_.
            poly_order (array[int]): The order of polynomials used to fit
                frequency as the function of volumes.
            min_method (string, optional): Minimisation algorithms, 'BFGS'/'L-BFGS-B'.
                See above.
            volume_bound (tuple-like), Boundary conditions of equilibrium
                volumes. Unit: :math:`\\AA^{3}`
            mutewarning (bool): Whether print out warning messages.
            \*\*kwargs: See below
            temperature (array[float]): Unit: K
            pressure (array[float]): Unit: GPa
            order (int): For DeltaFactor / Polynomial EOSs.
            min_ndata_factor, max_poly_order_factor, min_poly_order_factor (int):
                For Numerical EOS.
        Returns:
            self (Quasi_harmonic): New Attributes listed below
            self.temperature (array): Unit: K
            self.pressure (array): Unit: GPa
            self.volume (array): nPressure\*nTemperature, same below. Equilibrium volumes. Unit: :math:`\\AA^{3}`
            self.helmholtz (array): Helmholtz free energy. Unit: kJ/mol
            self.gibbs (array): Gibbs free energy. Unit: kJ/mol
            self.entropy (array): Entropy. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.c_v (array): Constant volume specific heat. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.k_t (array): Isothermal bulk modulus. Unit: GPa.
            self.eos_method (str): Name of the EOS.
            self.u0_fit (Pymatgen EOS): EOS used to fit DFT energy.
            self.eos (list[Pymatgen EOS]): Pymatgen EOS objects. EOS used to fit Helmholtz free energy.
            self.e0_eos_method: Deprecated. Synonym of 'self.eos_method'.
            self.e0_eos: Deprecated. Synonym of 'self.u0_fit'.

        :raise Exception: If temperature or pressure is defined neither here nor during initialization.
        """
        # Sanity check
        if self.ncalc < 3: raise Exception('Insufficient database. Increase HA phonons')

        if self.method != 'thermo_freq': refit = True
        else: refit = False

        # Temperature and pressure
        if 'temperature' in kwargs:
            if len(self.temperature)>0 and (mutewarning == False or refit == False):
                warn('Temperature attribute exists. Input temperatures will be used to update the attribute.', stacklevel=2)
            self.temperature = np.array(kwargs['temperature'], dtype=float, ndmin=1)
            refit = True
        if 'pressure' in kwargs:
            if len(self.pressure)>0 and (mutewarning == False or refit == False):
                warn('Pressure attribute exists. Input pressures will be used to update the attribute.', stacklevel=2)
            self.pressure = np.array(kwargs['pressure'], dtype=float, ndmin=1)
            refit = True
        if len(self.temperature)==0 or len(self.pressure)==0:
            raise Exception('Temperature and pressure should be specified.')

        if len(self.pressure) < 5:
            raise Exception("At least 5 pressures are required")

        # eos
        if hasattr(self, 'eos_method'):
            if self.eos_method != eos_method: refit = True
        else:
            refit = True

        # Polynomial, at least 1 redundant data
        poly_order = np.unique(np.array(poly_order, dtype=int, ndmin=1))
        poly_order = poly_order[np.where(poly_order<self.ncalc)[0]]
        if len(poly_order) == 0:
            raise Exception('At least order+1 phonon calculations are needed.')
        if hasattr(self, 'fit_order'):
            for i in poly_order:
                if i not in self.fit_order: refit = True; break
        else:
            refit = True

        # Min_method
        if hasattr(self, 'min_method'):
            if self.min_method != min_method: refit = True
        else:
            refit = True

        # Other args
        if np.all(volume_bound!=None) or 'order' in kwargs.keys() \
        or 'min_ndata_factor' in kwargs.keys() or 'max_poly_order_factor' in kwargs.keys() \
        or 'min_poly_order' in kwargs.keys(): refit = True

        if refit == False:
            warnings.warn('Nothing to re-fit. Return to the same object.', stacklevel=2)
            return self

        # Fit DFT total energy. Fitted values will not be covered.
        if self.method == 'thermo_freq' and hasattr(self, 'eos'):
            pass
        else:
            eosinp = {}; eos_method = eos_method.lower()
            for i in ['min_ndata_factor', 'max_poly_order_factor', 'min_poly_order_factor ']:
                if i in kwargs.keys(): eosinp[i] = kwargs[i]
            self.u0_fit = self.eos_fit(self.combined_volume, self.combined_u0, eos_method, **eosinp)
            self.eos_method = eos_method

        # Fit frequencies, Fitted values will not be covered.
        if self.method == 'thermo_freq' and hasattr(self, 'fit_order'):
            r2tot = [['unknown' for i in range(qha.nmode)] for j in range(qha.nqpoint)]
            r2avg='Not available for restarted calculations.'
        else:
            r2tot, r2avg = self.freq_polynomial_fit(order=poly_order)
            r2tot = [[float(j) for j in i] for i in r2tot]
            r2avg = float(r2avg)

        # Minimization
        self._clean_thermoprop()
        self.method = 'thermo_freq'
        self.min_method = min_method
        methods = {
            'BFGS': "vol = minimize(gibbs_opt, v_init, args=(t, p, obj, zp, wt, kBt), method='BFGS', jac='3-point')",
            'L-BFGS-B': "vol = minimize(gibbs_opt, v_init, args=(t, p, obj, zp, wt, kBt), method='L-BFGS-B', jac='3-point', bounds=volume_bound)",
        }

        # Expression of Gibbs free energy
        def gibbs_opt(volume, t, p, obj, zp, wt, kBt):
            volume = volume[0]
            dv = volume - obj.combined_volume[0]

            mTS = 0.
            if t > 1e-4:
                for iq in range(obj.nqpoint):
                    freq = np.array([i(dv) for i in obj.freq_fit[iq]])
                    beta = molh*freq[np.where(freq>1e-4)[0]]*1e9 / kBt
                    mTS += wt[iq] * kBt * np.sum(np.log(1 - np.exp(-beta)))
            return obj.u0_fit(volume) + zp(dv) + mTS + p*volume

        # Gibbs(V; T, p) minimization nPress*nTempt list
        self.volume = np.zeros([len(self.pressure), len(self.temperature)])
        v_init = np.mean(self.combined_volume)

        zp = 0. # analytical expression of U
        wt = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])
        for iq in range(self.nqpoint):
            zp += wt[iq] * 0.5 * molh * np.sum([self.freq_fit[iq][im] for im in range(self.nmode)])

        for idx_p, p in enumerate(self.pressure):
            for idx_t, t in enumerate(self.temperature):
                params = {'minimize': minimize,
                          'gibbs_opt': gibbs_opt,
                          'v_init': v_init,
                          't': t,
                          'p': p,
                          'obj' : self,
                          'zp' : zp,
                          'wt' : wt,
                          'kBt' : t*molk*1e-3,
                          'volume_bound': volume_bound}
                exec(methods[min_method], params)
                self.volume[idx_p, idx_t] = params['vol'].x[0]

                if (params['vol'].x[0] < min(self.combined_volume) or params['vol'].x[0] > max(self.combined_volume)) and not mutewarning:
                    warn('Optimized volume exceeds the sampled range. Special care should be taken of.\n  Volume: %12.4f, Temperature: %6.2f, Pressure: %6.2f\n'
                         % (params['vol'].x[0], t, p), stacklevel=2)

        self.helmholtz = np.zeros(self.volume.shape)
        self.gibbs = np.zeros(self.volume.shape)
        self.entropy = np.zeros(self.volume.shape)
        self.c_v = np.zeros(self.volume.shape)

        filterwarnings("ignore", 'MORE THAN 3 IMAGINARY MODES!')
        symm = self.combined_symm[:, :, 0]
        # empty eigenvector
        eigvt = np.array([[[[] for j in range(self.natom)] for k in range(self.nmode)] for l in range(self.nqpoint)])
        for idx_p, p in enumerate(self.pressure):
            for idx_t, t in enumerate(self.temperature):
                vol = self.volume[idx_p, idx_t]
                num_freq = np.zeros([self.nqpoint, self.nmode])
                dvol = vol - self.combined_volume[0]
                for iq in range(self.nqpoint):
                    for im in range(self.nmode):
                        num_freq[iq, im] = self.freq_fit[iq][im](dvol)
                ha = Harmonic(temperature=t, pressure=p).from_frequency(
                    self.u0_fit(vol), self.qpoint, num_freq, eigvt, symm,
                    natom=self.natom, volume=vol
                ).thermodynamics()
                self.helmholtz[idx_p, idx_t] = ha.helmholtz[0]
                self.gibbs[idx_p, idx_t] = ha.gibbs[0, 0]
                self.entropy[idx_p, idx_t] = ha.entropy[0]
                self.c_v[idx_p, idx_t] = ha.c_v[0]

        # Fit equation of states for K_T.
        self.eos = []; self.k_t = np.zeros(self.volume.shape)
        v = symbols('v')
        for idx_t, i in enumerate(self.temperature):
            eos = self.eos_fit(self.volume[:, idx_t], self.helmholtz[:, idx_t], self.eos_method, **eosinp)
            df = diff(eos(v), v, 2)
            lam_df = lambdify(v, df, 'numpy')
            self.k_t[:, idx_t] = self.volume[:, idx_t] * lam_df(self.volume[:, idx_t]) / molpv
            self.eos.append(eos)

        # Deprecated attributes and methods
        self.e0_eos = self.u0_fit
        self.e0_eos_method = self.eos_method
        if self.filefmt=='yaml':
            ThermoQHA.write_thermo_freq(self, r2tot, r2avg, min_method, volume_bound)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_thermo_freq(self, min_method, volume_bound)
        return self

    def thermo_gruneisen(self, eos_method='birch_murnaghan', poly_order=1,
                         min_method='BFGS', volume_bound=None, mutewarning=False,
                         **kwargs):
        """
        Grüneisen parameters and related properties. The macroscopic Grüneisen
        parameter is defined as:

        .. math::

            \\gamma=\\sum_{\\textbf{q}i}\\frac{\\gamma_{\\textbf{q}i}C_{V,\\textbf{q}i}}{C_{V}}

        Thermal expansion coefficient in Grüneisen model:

        .. math::

            \\alpha_{V}^{gru}=\\frac{\\gamma C_{V}}{K_{T}V}

        Therefore this method does not require polynomial fittings of
        volume-temperature for expansion rate, adiabatic bulk modulus and
        constant pressure specific heat.

        The initial steps are equivalent to ``self.thermo_freq()``.
        Grüneisen parameters are fitted afterwards. For arguments, see
        ``self.thermo_freq``.

        Returns:
            self (Quasi_harmonic): New attributes listed below. Other attributes are the same as ``self.thermo_freq``.
            self.gruneisen(array): npressure\*ntemperature, same below. Macroscopic Grüneisen parameter.
            self.alpha_v (array): Thermal expansion coefficient by Grüneisen method.
            self.c_p (array): Constant pressure specific heat by Grüneisen method. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.k_s (array): Adiabatic bulk modulus by Grüneisen method. Unit: GPa.
            self.alpha_vgru: Deprecated. Synonym of 'self.alpha_v'.
            self.c_pgru: Deprecated. Synonym of 'self.c_p'.
            self.k_sgru: Deprecated. Synonym of 'self.k_s'.
        """
        freqinp = dict(eos_method=eos_method, poly_order=poly_order,
                       min_method=min_method, volume_bound=volume_bound, mutewarning=mutewarning)
        for i in ['temperature', 'pressure', 'order', 'min_ndata_factor',
                  'max_poly_order_factor', 'min_poly_order_factor']:
            if i in kwargs.keys():
                freqinp[i] = kwargs[i]

        filterwarnings("ignore", 'Nothing to re-fit. Return to the same object.')
        self.method = 'thermo_freq'
        self.thermo_freq(**freqinp)
        self.method = 'thermo_gruneisen'

        # Get mode-specific and macroscopic Grüneisen parameter
        self.gruneisen = np.zeros(self.volume.shape)

        iT = np.where(self.temperature>1e-4)[0]
        vol = self.volume[:, iT]
        dvol = vol - self.combined_volume[0]
        kBT = molk * self.temperature[iT] # J/mol
        weight = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])
        for iq in range(self.nqpoint):
            wt = weight[iq]
            for im in range(self.nmode):
                gru = np.zeros(vol.shape)
                poly = self.freq_fit[iq][im]
                freq = poly(dvol)
                irow, icol = np.where(freq>1e-4)
                gru[irow, icol] = -vol[irow, icol]/freq[irow, icol] * poly.deriv(1)(dvol[irow, icol]) # nP*nT

                beta = freq*molh*1e12 / np.repeat(kBT[np.newaxis, :], len(self.pressure), axis=0) # nP*nT
                exp = np.exp(beta)
                c_v = np.zeros(vol.shape)
                c_v[irow, icol] = beta[irow, icol]**2 * molk / (exp[irow, icol] - 2 + 1/exp[irow, icol])
                self.gruneisen[:, iT] += wt * gru*c_v
        self.gruneisen[:, iT] =  self.gruneisen[:, iT] / self.c_v[:, iT]

        self.alpha_v = (self.c_v*self.gruneisen*1e-3) / (self.k_t*self.volume*molpv)
        self.c_p = self.c_v + self.alpha_v**2 * (self.k_t*self.volume*molpv) * self.temperature * 1e3
        self.k_s = np.zeros(self.volume.shape) + self.k_t
        self.k_s[:, iT] += self.k_t[:, iT] \
                         * (self.alpha_v[:, iT]**2 * self.temperature[iT] * self.volume[:, iT]*self.k_t[:, iT]*molpv) \
                         / (self.c_v[:, iT]*1e-3)

        # Deprecated attributes and methods
        self.alpha_vgru = self.alpha_v
        self.c_pgru = self.c_p
        self.k_sgru = self.k_s
        if self.filefmt=='yaml':
            ThermoQHA.write_thermo_gru(self)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_thermo_gru(self, min_method, volume_bound)
        return self

    def thermo_eos(self, eos_method='birch_murnaghan', poly_order=[3, 4],
                   min_method='BFGS', volume_bound=None, mutewarning=False,
                   **kwargs):
        """
        Obtain thermodynamic properties by fitting EOS, which is fitted by the
        Helmholtz free energies of sampled harmonic phonons. The explicit
        sorting and fitting of frequency-volume relationship is disabled.

        The equilibrium volume is fitted by minimizing the difference between
        analytical pressure and the given pressure at constant temperature.

        .. math::

            V(T,p_{0})=\\text{min}\\left[
                -\\left(
                    \\frac{\\partial F(V)}{\\partial V}
                \\right)_{T} - p_{0}
            \\right]^{2}

        Parameterized and tested algorithms for ``min_method``:

        * BFGS(no boundary)  
        * L-BFGS-B(with boundary)

        Entropy is obtained by taking the derivative of Gibbs free energy at
        constant pressure.

        .. math::

            S=-\\left(\\frac{\\partial G}{\\partial T}\\right)_{p}

        Constant pressure specific heat is obtained by taking the second
        derivative of :math:`G`.

        .. math::

            C_{p}=-T\\left(\\frac{\\partial^{2}G}{\\partial T^{2}}\\right)_{p}

        :math:`G(T)` is fitted as polynomial specified by ``poly_order``. The
        first order is forced to be 0 to ensure :math:`S=0` at 0 K.

        .. note::

            For a good fitting of :math:`G(T)`, entropy and c_p, the number of
            temperatures must >= 5. ``poly_order`` must > 2.

        Args:
            eos_method (str): EOS used to fit DFT total energy and Helmholtz
                free energy (to get bulk modules). Valid entries are consistent
                with `PyMatGen eos module <https://pymatgen.org/pymatgen.analysis.html#module-pymatgen.analysis.eos>`_.
            poly_order (array[int]): The order of polynomials used to fit
                Gibbs free energy as the function of volumes.
            min_method (string, optional): Minimisation algorithms, 'BFGS'/'L-BFGS-B'.
                See above.
            volume_bound (tuple-like), Boundary conditions of equilibrium
                volumes. Unit: :math:`\\AA^{3}`
            mutewarning (bool): Whether print out warning messages.
            \*\*kwargs: See below
            temperature (array[float]): Unit: K
            pressure (array[float]): Unit: GPa
            order (int): For DeltaFactor / Polynomial EOSs.
            min_ndata_factor, max_poly_order_factor, min_poly_order_factor (int):
                For Numerical EOS.
        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.method (str): 'thermo_eos'
            self.temperature (array): Unit: K
            self.pressure (array): Unit: GPa
            self.volume (array): nPressure\*nTemperature, same below. Equilibrium volumes. Unit: :math:`\\AA^{3}`
            self.helmholtz (array): Helmholtz free energy. Unit: kJ/mol
            self.gibbs (array): Gibbs free energy. Unit: kJ/mol
            self.entropy (array): Entropy. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.c_p (array): Constant pressure specific heat. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.eos (list[Pymatgen EOS]): nTemperature\*1 list of Pymatgen EOS objects. EOSs used to fit HA free energy at constant temperature.
            self.eos_method (str): The name of EOS used.
            self.gibbs_fit (list[Polynomial]): nPressure list of Polynomials of fitted Gibbs free energy, for entropy and c_p.
            self.fe_eos: Deprecated. Synonym of 'self.eos'.
            self.fe_eos_method: Deprecated. Synonym of 'self.fe_eos_method'.

        :raise Exception: If the number of HA calculations is less than 4.
        :raise Exception: If temperature or pressure is defined neither here nor during initialization.
        """
        # Sanity check
        if self.ncalc < 4: raise Exception('Insufficient database. Increase HA phonons')

        if self.method != 'thermo_eos': refit = True
        else: refit = False

        # Temperature and pressure
        if 'temperature' in kwargs:
            if len(self.temperature)>0 and (mutewarning == False or refit == False):
                warn('Temperature exists. Using new temperatures will update all the fittings if present.', stacklevel=2)
            self.temperature = np.array(kwargs['temperature'], dtype=float, ndmin=1)
            refit = True
        if 'pressure' in kwargs:
            if len(self.pressure)>0 and (mutewarning == False or refit == False):
                warn('Pressure exists. Using new pressures will update all the fittings if present.', stacklevel=2)
            self.pressure = np.array(kwargs['pressure'], dtype=float, ndmin=1)
            refit = True
        if len(self.temperature)==0 or len(self.pressure)==0:
            raise Exception('Temperature and pressure should be specified.')

        if len(self.temperature) < 5:
            raise Exception("At least 5 temperatures are required")

        # eos
        if hasattr(self, 'eos_method'):
            if self.eos_method != eos_method: refit = True
        else:
            refit = True

        # polynomial, at least 1 redundant data points
        poly_order = np.unique(np.array(poly_order, dtype=int, ndmin=1))
        poly_order = poly_order[np.where((poly_order<len(self.temperature))&(poly_order>2))[0]]
        if len(poly_order) == 0:
            raise Exception('At least a cubic polynomial and order+1 temperatures are needed for polynomial fitting.')
        if hasattr(self, 'fit_order'):
            for i in poly_order:
                if i not in self.fit_order: refit = True; break
        else:
            refit = True

        # Min_method
        if hasattr(self, 'min_method'):
            if self.min_method != min_method: refit = True
        else:
            refit = True

        # Other args
        if np.all(volume_bound!=None) or 'order' in kwargs.keys() \
        or 'min_ndata_factor' in kwargs.keys() or 'max_poly_order_factor' in kwargs.keys() \
        or 'min_poly_order' in kwargs.keys(): refit = True

        if refit == False:
            warnings.warn('Nothing to re-fit. Return to the same object.', stacklevel=2)
            return self

        # Fit EOS
        self._clean_thermoprop()
        self.method = 'thermo_eos'
        self.fit_order = poly_order
        helmholtz = np.zeros([len(self.temperature), self.ncalc], dtype=float)
        # empty eigenvector
        eigvt = np.array([[[[] for j in range(self.natom)] for k in range(self.nmode)] for l in range(self.nqpoint)])
        for idx_c in range(self.ncalc):
            ha = Harmonic().from_frequency(self.combined_u0[idx_c],
                                           self.qpoint,
                                           self.combined_freq[:, :, idx_c],
                                           eigvt,
                                           self.combined_symm[:, :, idx_c],
                                           natom=self.natom,
                                           volume=self.combined_volume[idx_c])
            ha.thermodynamics(temperature=self.temperature, pressure=[0.])
            helmholtz[:, idx_c] = ha.helmholtz

        eos_method = eos_method.lower()
        self.eos_method = eos_method
        self.eos = []
        eosinp = {}
        for i in ['min_ndata_factor', 'max_poly_order_factor', 'min_poly_order_factor ']:
            if i in kwargs.keys(): eosinp[i] = kwargs[i]
        for it, t in enumerate(self.temperature):
            self.eos.append(
                self.eos_fit(self.combined_volume, helmholtz[it, :], eos_method, **eosinp)
            )

        # Get thermoproperties
        self.volume = np.zeros([len(self.pressure), len(self.temperature)])
        self.helmholtz = np.zeros(self.volume.shape)
        self.gibbs = np.zeros(self.volume.shape)
        self.entropy = np.zeros(self.volume.shape)
        self.c_p = np.zeros(self.volume.shape)
        self.k_t = np.zeros(self.volume.shape)
        v = symbols('v')
        if np.all(volume_bound==None):
            minp = {'method':'BFGS', 'jac':'3-point'}
        else:
            minp = {'method':'L-BFGS-B', 'jac':'3-point', 'bounds':volume_bound}
        for it, eos in enumerate(self.eos):
            p_eos = -diff(eos(v), v, 1)
            for ip, p in enumerate(self.pressure):
                p_kj = p * Avogadro / 1e24  # GPa --> kJ/mol.Angstrom^3
                lam_p = lambdify(v, (p_eos - p_kj)**2, 'numpy')
                fit = minimize(lam_p, eos.v0, **minp)
                if fit.success == False:
                    raise Exception('EOS fitting failed at %6.2f K, %6.2f GPa. More sampling points needed.' % (self.temperature[idx_t], p))
                if (fit.x[0] < min(self.combined_volume) or fit.x[0] > max(self.combined_volume)) and not mutewarning:
                    warn('Optimized volume exceeds the sampled range. Special care should be taken of.\n  Volume: %12.4f, Temperature: %6.2f, Pressure: %6.2f\n'
                         % (fit.x[0], self.temperature[it], p), stacklevel=2)
                self.volume[ip, it] = fit.x[0]
                self.helmholtz[ip, it] = eos(fit.x[0])
                self.gibbs[ip, it] = eos(fit.x[0]) + p_kj * fit.x[0]

            second = lambdify(v, diff(eos(v), v, 2), 'numpy')
            self.k_t[:, it] = self.volume[:, it] * second(self.volume[:, it]) / molpv

        # Second fit G(T; p), get entropy and C_p.
        self.gibbs_fit = []; r2tot = []
        for ip, gb in enumerate(self.gibbs):
            allr2 = []; allfunc = []
            for o in poly_order:
                # The first order term is 0. Constant and higher orders are kept
                deg = [i+1 for i in range(o)]; deg[0] = 0
                coef, lst = polyfit(self.temperature, gb, deg=deg, full=True)
                poly = Polynomial(coef)
                allr2.append(1 - lst[0][0]/np.sum((gb - np.mean(gb))**2))
                allfunc.append(poly)
            idx = np.argmax(allr2)
            self.gibbs_fit.append(allfunc[idx])
            r2tot.append(allr2[idx])
        r2tot = np.array(r2tot)
        r2avg = np.mean(r2tot)

        for ip in range(self.pressure.shape[0]):
            func = self.gibbs_fit[ip]
            entropy = func.deriv(1)
            self.entropy[ip, :] = -entropy(self.temperature) * 1000.
            c_p = func.deriv(2)
            self.c_p[ip, :] = -c_p(self.temperature) * 1000 * self.temperature

        # Deprecated attributes and methods
        self.fe_eos_method = self.eos_method
        self.fe_eos = self.eos
        if self.filefmt=='yaml':
            ThermoQHA.write_thermo_eos(self, r2tot.tolist(), float(r2avg), min_method, volume_bound)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_thermo_eos(self)
        return self

    def expansion_vol(self, poly_order=[2, 3], plot=True, fit_fig='expansion_fit.png'):
        """
        Fit the thermal expansion curve as polynomials and get thermal expansion
        coefficients at equilibrium volumes.

        The volumetric thermal expansion coefficient at constant pressure:

        .. math::

            \\alpha_{V}(T) = \\frac{1}{V(T)}\\left(\\frac{\\partial V(T)}{\\partial T}\\right)_{p}

        For thermal expansion with Grüneisen model, please refer to the
        ``thermo_gruneisen()`` method.

        .. note::

            For a good fitting. ``poly_order`` must be no smaller than 2.

        Args:
            poly_order (list[int]): Order of polynomials.
            plot (bool): Plot V-T curves to examine the goodness of fitting. An
                interactive window will pump out to let user to specify the
                optimial fitting.
            fit_fig (str): File name for fittings. A temperal figure is printed
                to help the user choose the optimal fitting.

        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.vol_fit (list): 1\*nPressure. List of Numpy polynomial object, the fitted volume V(T).
            self.alpha_v (array): nPressure\*nTemperature. Expansion coefficients at equilibrium volumes.
        """
        import matplotlib.pyplot as plt
        import matplotlib.colors as mcolors

        # Sanity check
        if not hasattr(self, 'volume'):
            raise Exception('Equilibrium volume should be fit first.')
        if hasattr(self, 'alpha_v'):
            warn("The fitted thermal expansion coefficient will be overwritten.", stacklevel=2)

        # polynomial, at least 2 redundant data points
        poly_order = np.unique(np.array(poly_order, dtype=int, ndmin=1))
        poly_order = poly_order[np.where((poly_order<self.ncalc)&(poly_order>=2))[0]]
        if len(poly_order) == 0:
            raise Exception('At least order+1 calculations are needed for polynomial fitting. Order of polynomials must >= 2.')

        # Polynomial fitting, nPressure
        func = []
        r2tot = []
        iT = np.argmin(self.temperature)
        dt = self.temperature - self.temperature[iT]
        dv = (self.volume.T - self.volume[:, iT].T).T
        for ip, dvp in enumerate(dv):
            func_p = []
            r2_p = []
            for o in poly_order:
                deg = [i+1 for i in range(o)]
                coef, lst = polyfit(dt, dvp, deg=deg[1:], full=True) # Force \alpha(0K) = 0
                poly = Polynomial(coef)
                r2_p.append(1 - lst[0][0]/np.sum((dv - np.mean(dv))**2))
                func_p.append(poly+self.volume[ip, iT])
            idx = np.argmax(r2_p)
            func.append(func_p[idx])
            r2tot.append(r2_p[idx])
        self.vol_fit = func
        r2tot = np.array(r2tot)
        r2avg = np.mean(r2tot)

        if plot == True:
            fig, ax = plt.subplots(1, 1, figsize=(8, 6))
            clist = list(mcolors.TABLEAU_COLORS.keys())
            T = np.linspace(self.temperature.min(), self.temperature.max(), 1000)
            dT = T - self.temperature.min()
            for ip, p in enumerate(self.pressure):
                ax.scatter(self.temperature, self.volume[ip], color='k', marker='D', s=40)
                c = clist[ip % len(clist)]
                label = 'Pressure {:.4f}, Order {:d}, R^2 {:.4f}'.format(p, len(func[ip].coef)-1, r2tot[ip])
                ax.plot(T, func[ip](dT), color=c, label=label)
            ax.legend(loc='lower right')
            ax.set_xlabel('Temperature (K)')
            ax.set_ylabel(r'Volume ($\AA^{3}$)')
            fig.savefig(fname=fit_fig, dpi=200)

        # Expansion coefficients
        self.alpha_v = np.zeros([len(self.pressure), len(self.temperature)])
        dT = self.temperature - self.temperature.min()
        for idx_p, v_p in enumerate(self.volume):
            self.alpha_v[idx_p, :] = self.vol_fit[idx_p].deriv(1)(dT) / self.vol_fit[idx_p](dT)

        # Deprecated attributes and methods
        if self.filefmt=='yaml':
            ThermoQHA.write_expansion_vol(self, poly_order, r2tot.tolist(), float(r2avg))
        elif self.filefmt=='txt':
            ThermoQHA.old_write_expansion_vol(self, r2tot, r2avg)
        return self

    def bulk_modulus(self, adiabatic=True, **kwargs):
        """
        Calculate isothermal and adiabatic bulk moduli at equilibrium volumes.

        The following equation is used:

        .. math::

            K_{S} = K_{T} + \\frac{\\alpha^{2}_{V}VTK^{2}_{T}}{C_{V}}

        Args:
            adiabatic (bool): Deprecated. Not used.
            \*\*kwargs: Deprecated. Not used.

        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.k_s (array): nPressure\*nTemperature. Adiabatic bulk modulus. Unit: GPa.
        """
        # Sanity check
        if not hasattr(self, 'alpha_v'):
            raise AttributeError('Expansion coefficient should be fit at first.')
        if hasattr(self, 'k_s'):
            warn("Attributes 'k_s' exists, nothing to update.", stacklevel=2)
            return self

        self.k_s = np.zeros(self.k_t.shape) + self.k_t
        if not hasattr(self, 'c_v'): self.specific_heat()

        iT = np.where(self.temperature > 1e-4)[0] # > 0K
        self.k_s[:, iT] += self.k_t[:, iT] \
                         * (self.alpha_v[:, iT]**2 * self.temperature[iT] * self.volume[:, iT]*self.k_t[:, iT]*molpv) \
                         / (self.c_v[:, iT]*1e-3)

        # Deprecated attributes and methods
        if self.filefmt=='yaml':
            ThermoQHA.write_bulk_modulus(self)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_bulk_modulus(self, adiabatic)
        return self

    def specific_heat(self):
        """
        Calculate constant volume or pressure specific heat at equilibrium volumes.

        The following equation is used:

        .. math::

            C_{p} - C_{V} = \\alpha_{V}^{2}K_{T}VT

        .. note::

            * Must call ``expansion_vol()`` method first.
            * When ``thermo_freq()`` was called, this method fits ``c_p``.
            * When ``thermo_eos()`` was called, this method fits ``c_v``.
            * When ``thermo_gruneisen()`` was called, this method does nothing
                and prints the warning message because ``c_p`` has been fitted.

        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.c_v (array): nPressure\*nTemperature. Constant volume specific heat. Unit: J/mol/K
            self.c_p (array): nPressure\*nTemperature. Constant pressure specific heat. Unit: J/mol/K.
        """
        # Sanity check
        if not hasattr(self, 'alpha_v'):
            raise AttributeError('Expansion coefficient should be fit at first.')

        if not hasattr(self, 'c_p'): # thermo_freq
            self.c_p = self.c_v + self.alpha_v**2 * self.k_t * self.volume * self.temperature * molpv*1000
        elif not hasattr(self, 'c_v'): # thermo_eos
            self.c_v = self.c_p - self.alpha_v**2 * self.k_t * self.volume * self.temperature * molpv*1000
        else:
            warn("Attributes 'c_v' and 'c_p' both exist. Nothing is updated.", stacklevel=2)

        # Deprecated attributes and methods
        if self.filefmt=='yaml':
            ThermoQHA.write_specific_heat(self)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_specific_heat(self, adiabatic)
        return self

#     def expansion_lin(self, poly_order=[2, 3], interp=None):
#         """
#         Fit linear expansions of lattice parameters by the 2-order Taylor
#         expansion.

#         .. math::

#             G(\\mathbf{p})=G_{0}(\\mathbf{p_{0}})+\\Delta\\mathbf{p}^{T}\\mathbf{H}\\Delta\\mathbf{p}

#         :math:`G` is Gibbs free energy. :math:`\mathbf{p}` is the vector
#         of lattice parameters. :math:`\Delta\mathbf{p}` means the
#         difference between the fitted and equilibrium lattice parameters.
#         :math:`\mathbf{H}` is the Hessian of :math:`G` and displacements
#         along lattice parameters.

#         The RMS deviations (RMSD) of the following equation is minimized
#         at constant temperature and pressure. But deviations from
#         equilibrium volume might occur. RMSD of Gibbs free energy is
#         available in output file only.

#         .. math::

#             \\mathbf{p_{0}} = \\min\\left\\{\\Delta\\mathbf{p}^{T}\\mathbf{H}\\Delta\\mathbf{p} - [G(\\mathbf{p})-G_{0}(T,p)]\\right\\}

#         .. note::

#             N. Raimbault, V. Athavale and M. Rossi, *Phys. Rev. Materials*, 2019, **3**, 053605.

#         This method requires a larger number of HA calculations to ensure
#         a small RMSD. Typically the number of HA calculations should
#         follow the equation below, otherwise the warning massage is given.

#         .. math::

#             n_{HA} \\geq n_{latt} + \\sum_{i=1}^{n_{latt}}i

#         :math:`n_{latt}` is the lenth of the minimial set of lattice parameters.
#         The optimized lattice parameters at DFT level are used for fitting.

#         To avoid warnings, use ``interp`` to linearly interpolate the lattice
#         parameters and to get thermodynamic properties from the fitted QHA object.

#         Args:
#             poly_order (list[int]): Order of polynomials used to fit the
#                 linear expansion coefficients. The optimal fit across the
#                 sampled temperature and pressure range of a certain lattice
#                 parameter is automatically chosen based on :math:`R^{2}`.
#             interp (int): Number of interpolated geometries. All the HA
#                 geometries are used besides the interpolated ones.

#         Returns:
#             self (Quasi_harmonic): New attributes listed below
#             self.lattice (array): nPressure\*nTemperature\*nLattice. The equilibrium values of minimal set of lattice parameters.
#             self.latt_fit (list): nPressure\*nLattice. Numpy polynomial object, the fitted a(v). Linear part only.
#             self.alpha_latt (array): nPressure\*nTemperature\*nLattice. Linear expansion coefficients. Linear part only.
#         """
#         # from pymatgen.symmetry.analyzer import SpacegroupAnalyzer
#         from pymatgen.core.lattice import Lattice
#         from CRYSTALpytools.thermodynamics import Output
#         from scipy.optimize import least_squares
#         import numpy as np
#         import warnings

#         if not hasattr(self, 'volume'):
#             raise AttributeError('Equilibrium volume should be fit first.')

#         if not hasattr(self.combined_phonon[0], 'structure'):
#             raise AttributeError('No lattice information is found in input HA calculations.')

#         poly_order = np.unique(np.array(poly_order, dtype=int))
#         poly_order = poly_order[np.where(poly_order<self.ncalc)[0]]
#         if max(poly_order) > len(self.temperature) - 1:
#             warnings.warn('Sampled temperature points are not sufficient for the order of polynomial fitting. Some values will be removed.',
#                           stacklevel=2)

#         # Analyze the refined geometry and return to reference lattice vectors
#         latt_ref = []
#         for phonon in self.combined_phonon:
#             struc = phonon.structure
#             struc.standarize_pbc()
#             struc.refine_geometry()
#             latt = struc.platt
#             sg = struc.sg
#             if sg > 195: # cubic
#                 warnings.warn('''Cubic lattice! Use self.expansion_vol.
# self.lattice is stored as a nPressure * nTemperature array.''')
#                 return self

#             latt_ref.append(latt)

#         latt_ref = np.array(latt_ref)
#         # Add interpolated points
#         if np.all(interp!=None):
#             # Lattice
#             interp_latt = np.linspace(np.min(latt_ref, axis=0),
#                                       np.max(latt_ref, axis=0),
#                                       interp + 2)
#             latt_ref = np.vstack([latt_ref, interp_latt[1:-1, :]])
#             ncalc = self.ncalc + interp
#             # Volume
#             combined_volume = self.combined_volume
#             for latt in interp_latt:
#                 if len(latt) == 6:
#                     combined_volume = np.append(
#                         combined_volume,
#                         Lattice.from_parameters(a=latt[0],
#                                                 b=latt[1],
#                                                 c=latt[2],
#                                                 alpha=latt[3],
#                                                 beta=latt[4],
#                                                 gamma=latt[5]).volume
#                     )
#                 elif len(latt) == 4:
#                     combined_volume = np.append(
#                         combined_volume,
#                         Lattice.from_parameters(a=latt[0],
#                                                 b=latt[1],
#                                                 c=latt[2],
#                                                 alpha=90.,
#                                                 beta=latt[3],
#                                                 gamma=90.).volume
#                     )
#                 elif len(latt) == 3:
#                     combined_volume = np.append(
#                         combined_volume,
#                         Lattice.from_parameters(a=latt[0],
#                                                 b=latt[1],
#                                                 c=latt[2],
#                                                 alpha=90.,
#                                                 beta=90.,
#                                                 gamma=90.).volume
#                     )
#                 elif len(latt) == 2 and sg >= 75 and sg < 143: # Tetragonal
#                      combined_volume = np.append(
#                         combined_volume,
#                         Lattice.from_parameters(a=latt[0],
#                                                 b=latt[0],
#                                                 c=latt[1],
#                                                 alpha=90.,
#                                                 beta=90.,
#                                                 gamma=90.).volume
#                     )
#                 elif len(latt) == 2 and sg >= 143 and sg < 195: # Hexagonal and trigonal
#                      combined_volume = np.append(
#                         combined_volume,
#                         Lattice.from_parameters(a=latt[0],
#                                                 b=latt[0],
#                                                 c=latt[1],
#                                                 alpha=90.,
#                                                 beta=90.,
#                                                 gamma=120.).volume
#                     )
#         else:
#             ncalc = self.ncalc
#             combined_volume = self.combined_volume

#         x0 = np.average(latt_ref, axis=0)
#         # Hessian initial guess - elementary matrix
#         hess_dimen = len(x0)
#         hess_init_mx = np.eye(hess_dimen)
#         hess_init = []
#         for i in range(hess_dimen):
#             for j in range(i, hess_dimen):
#                 hess_init.append(hess_init_mx[i, j])

#         x0 = np.concatenate([x0, hess_init])
#         if ncalc < len(x0):
#             warnings.warn('The number of sampled points is less than number of unknowns. Large deviation is expected.',
#                           stacklevel=2)

#         # Minimize error of Gibbs free energy
#         self.lattice = np.zeros([len(self.pressure), len(self.temperature), hess_dimen])
#         e_err = np.zeros([len(self.pressure), len(self.temperature)], dtype=float)
#         for idx_p, p in enumerate(self.pressure):
#             for idx_t, t in enumerate(self.temperature):
#                 fe_eq = self.gibbs[idx_p, idx_t]
#                 fe_ref = np.zeros([len(combined_volume),], dtype=float)
#                 for idx_v, v in enumerate(combined_volume):
#                     ha = self._get_harmonic_phonon(v)
#                     ha.thermodynamics(temperature=t, pressure=p)
#                     fe_ref[idx_v] = ha.gibbs[0, 0, 0]

#                 opt_out = least_squares(self._minimize_latt, x0,
#                                         args=(fe_eq, latt_ref, fe_ref))
#                 self.lattice[idx_p, idx_t, :] = opt_out.x[:hess_dimen]
#                 e_err[idx_p, idx_t] = opt_out.fun

#         # Polynomial fit: For thermal expansion coefficients. Linear part only.
#         if sg >= 1 and sg < 75: # abc
#             latt_fit = self.lattice[:, :, 0:3]
#         elif sg >= 75 and sg < 195: # ac
#             latt_fit = self.lattice[:, :, 0:2]

#         r_square = np.zeros([latt_fit.shape[0], latt_fit.shape[2], len(poly_order)]) # nPress * nLatt * nOrder
#         poly_fit = [[[None for i in range(len(poly_order))] for j in range(latt_fit.shape[2])] for k in range(latt_fit.shape[0])] # nPress * nLatt * nOrder
#         idx_tmin = np.argmin(self.temperature)
#         dt = self.temperature - self.temperature[idx_tmin]
#         for idx_p, p in enumerate(self.pressure):
#             latt_t = self.lattice[idx_p, :, :] # nTempt * nLatt
#             latt_t = np.transpose(latt_t, axes=(1, 0)) # nLatt * nTempt
#             for idx_latt, latt in enumerate(latt_t):
#                 dlatt = latt - latt[idx_tmin]
#                 for idx_order, order in enumerate(poly_order):
#                     opt_out = least_squares(self._poly_no_cst,
#                                             np.array([1. for i in range(order)]),
#                                             args=(dt, dlatt))
#                     poly = np.polynomial.polynomial.Polynomial(np.insert(opt_out.x, 0, 0.))
#                     poly_fit[idx_p][idx_latt][idx_order] = poly
#                     rs = 1 - np.sum((dlatt - poly(dt))**2) / np.sum((dlatt - np.mean(dlatt))**2)
#                     r_square[idx_p, idx_latt, idx_order] = rs

#         # Find the optimal fit
#         self.latt_fit = [[None for i in range(latt_fit.shape[2])] for j in range(latt_fit.shape[0])] # nPress * nLatt
#         fit_order = [None for i in range(latt_fit.shape[2])] # nLatt * 1 list
#         r_square = np.transpose(r_square, (1, 0, 2)) # nLatt * nPress * nOrder
#         for idx_latt, rs_latt in enumerate(r_square):
#             rs_mean = np.array([np.mean(rs_latt[:, i]) for i in range(len(poly_order))])
#             fit_order_idx = np.argmax(rs_mean)
#             fit_order[idx_latt] = poly_order[fit_order_idx]
#             for idx_p in range(latt_fit.shape[0]):
#                 self.latt_fit[idx_p][idx_latt] = poly_fit[idx_p][idx_latt][fit_order_idx]
#         # Numerize the linear expansion
#         self.alpha_latt = np.zeros([latt_fit.shape[0], latt_fit.shape[1], latt_fit.shape[2]]) # nPress * nTempt * nLatt
#         idx_tmin = np.argmin(self.temperature)
#         dt = self.temperature - self.temperature[idx_tmin]
#         for idx_p, p in enumerate(self.pressure):
#             for idx_latt in range(latt_fit.shape[2]):
#                 lattmin = self.lattice[idx_p, idx_tmin, idx_latt]
#                 self.alpha_latt[idx_p, :, idx_latt] = \
#                     self.latt_fit[idx_p][idx_latt].deriv(1)(dt) / (self.latt_fit[idx_p][idx_latt](dt) + lattmin)
#         # Lowest temperature, alpha = 0
#         self.alpha_latt[:, idx_tmin, :] = 0.

#         # Print output file
#         if np.all(self.filename!=None):
#             Output.write_expansion_latt(self, e_err, fit_order,
#                                         r_square[:, :, fit_order_idx])
#         return self

    def _combine_data(self, ha_list, mode_sort_tol):
        """
        Combine the HA calculation data and rearrange it in the ascending order
        of volumes.

        Args:
            ha_list (list[Harmonic]): List of harmonic objects.
            mode_sort_tol (float | None)

        Returns:
            close_overlap (array[float]):ncalc\*nmode\*nmode boolean matrix
                (only 1 and 0). Whether close overlap is identified between the
                previous calculation (2nd dimension) and the current one (3rd).
            self : Attributes listed below.
            combined_volume (array[float]): 1\*nCalc
            combined_u0 (array[float]): 1\*nCalc
            combined_freq (array[float]): nQpoint\*nMode\*nCalc
            combined_symm (array[str]): nQpoint\*nMode\*nCalc
            nqpoint (int):
            qpoint (array[float]): nQpoint\*4
            nmode (int):
            natom (int):

        :raise Exception: If number of q points, modes or atoms are not consistent across the HA calculations.
        """
        # Sorting data according to volumes
        sorted_vol = np.zeros([self.ncalc, 2])
        nqpoint = ha_list[0].nqpoint
        nmode = ha_list[0].nmode  # int
        natom = ha_list[0].natom  # int
        for index, ha_phonon in enumerate(ha_list):
            sorted_vol[index, :] = [index, ha_phonon.volume]
            # Check whether the numbers of modes and atoms are consistent.
            if (natom-ha_phonon.natom != 0) or (nmode-ha_phonon.nmode != 0) \
            or (nqpoint-ha_phonon.nqpoint != 0):
                raise Exception('The number of qpoints, modes or atoms is not consistent across the sampling points')

        sorted_vol = sorted_vol[np.argsort(sorted_vol[:, 1])]
        if ha_list[0].eigenvector.size == 0:
            do_eigvt = False
        else:
            do_eigvt = True

        combined_phonon = []
        # Volume, ncalc * 1 array
        combined_volume = np.zeros(self.ncalc)
        # DFT total energy, ncalc * 1 array
        combined_u0 = np.zeros(self.ncalc)
        # Frequency, ncalc * nqpoint * nmode array
        combined_freq = np.zeros([self.ncalc, nqpoint, nmode])
        # Symmetry, ncalc * nqpoint * nmode array
        combined_symm = [[] for i in range(self.ncalc)]
        # Eigenvector, ncalc * nqpoint * nmode * natom * 3 array
        combined_eigvt = np.zeros([self.ncalc, nqpoint, nmode, natom, 3], dtype=complex)

        for idx_new, idx_vol in enumerate(sorted_vol):
            ha_phonon = ha_list[int(idx_vol[0])]
            combined_phonon.append(ha_phonon)
            combined_volume[idx_new] = idx_vol[1]
            combined_u0[idx_new] = ha_phonon.u_0
            combined_freq[idx_new] = ha_phonon.frequency
            combined_symm[idx_new] = ha_phonon.mode_symm
            if do_eigvt == True:
                combined_eigvt[idx_new] = ha_phonon.eigenvector
        combined_symm = np.array(combined_symm, dtype=str)

        # ncalc * nqpoint * nmode array to nqpoint * ncalc * nmode array
        combined_freq = np.transpose(combined_freq, axes=[1, 0, 2])
        if do_eigvt == True:
            # ncalc * nqpoint * nmode * natom * 3 array to nqpoint * ncalc * nmode * natom * 3 array
            combined_eigvt = np.transpose(combined_eigvt, axes=[1, 0, 2, 3, 4])

        # Sort phonon modes if requested
        close_overlap = np.zeros([nqpoint, self.ncalc, nmode, nmode], dtype=int)
        combined_symm = np.transpose(combined_symm, axes=[1,0,2]) # nqpoint * ncalc * nmode
        ## Sort
        if np.all(mode_sort_tol!=None) and do_eigvt == True:
            for idx_q in range(nqpoint):
                combined_freq[idx_q], combined_eigvt[idx_q], close_overlap[idx_q] \
                    = self._phonon_continuity(combined_freq[idx_q],
                                              combined_eigvt[idx_q],
                                              symm=combined_symm[idx_q],
                                              mode_sort_tol=mode_sort_tol)
            # nqpoint * ncalc * nmode_ref * nmode_sort array to nqpoint * nmode_ref * ncalc * nmode_sort array
            close_overlap = np.transpose(close_overlap, axes=[0, 2, 1, 3])
            for q, overlap_q in enumerate(close_overlap):
                n_overlap = int(np.sum(overlap_q))
                if n_overlap > 0:
                    warn(
                        'Close overlap of phonon modes detected at qpoint {}: {} overlaps out of {}*{} mode combinations at this point.'.format(q, n_overlap, nmode, nmode),
                        stacklevel=2
                    )
        elif np.all(mode_sort_tol!=None) and do_eigvt == False:
            warn('Eigenvectors not read. Mode sorting not available.', stacklevel=2)

        # nqpoint * ncalc * nmode array to nqpoint * nmode * ncalc array
        combined_freq = np.transpose(combined_freq, axes=[0, 2, 1])
        combined_symm = np.transpose(combined_symm, axes=[0, 2, 1])
        if do_eigvt == True:
            # nqpoint * ncalc * nmode * natom * 3 array to nqpoint *  nmode * ncalc * natom * 3 array
            combined_eigvt = np.transpose(combined_eigvt, axes=[0, 2, 1, 3, 4])

        self.combined_volume = combined_volume
        self.combined_u0 = combined_u0
        self.combined_freq = combined_freq
        self.combined_symm = combined_symm
        self.nqpoint = nqpoint
        self.qpoint = ha_list[0].qpoint
        self.nmode = nmode
        self.natom = natom
        return close_overlap

    @staticmethod
    def _phonon_continuity(freq, eigvt, symm=None, mode_sort_tol=0.4):
        """
        Rearrange phonon modes by their continuity. If the difference between
        the maximum scalar product of corresponding eigenvectors (normalized to
        1) and scalar products of other modes is less than 0.4, warning is
        printed due to the potential overlap of modes. Adopted from CRYSTAL17.

        .. note::

            A. Erba, *J. Chem. Phys.*, 2014, **141**, 124115.

        Args:
            freq (array[float]): Phonon frequencies. Unit: THz
            eigvt (array[float]): Eigenvectores normalized to 1
            symm (array[str]): Irreducible representations in Mulliken symbols.
            mode_sort_tol (float): The threshold of close mode overlaps.

        Returns:
            freq (array[float]): Sorted phonon frequencies
            eigvt (array[float]): Sorted eigenvectores
            close_overlap (array[float]):ncalc\*nmode\*nmode boolean matrix
                (only 1 and 0). Whether close overlap is identified between the
                previous calculation (2nd dimension) and the current one (3rd).
        """
        # Exclude negative and 0 frequencies
        ncalc = len(freq)
        nmode = len(freq[0])

        # Sort phonon
        close_overlap = np.zeros([ncalc, nmode, nmode])
        for sort_c in range(1, ncalc):
            ref_c = sort_c - 1
            ref_eigvt = deepcopy(eigvt[ref_c])
            sort_eigvt = deepcopy(eigvt[sort_c])
            ref_eigvt = np.reshape(ref_eigvt, [nmode, nmode], order='C')
            sort_eigvt = np.reshape(sort_eigvt, [nmode, nmode], order='C')
            mode_product = np.abs(ref_eigvt @ sort_eigvt.conjugate().T) # row: ref_m, col: sort_m
            del ref_eigvt, sort_eigvt # save some space

            # subdivide the matrix by symmetry
            symm_product = []; irow = []; icol = [];
            if len(symm[0]) != 0:
                unique_symm = set(symm[0].tolist())
                for s in unique_symm:
                    idx_row = np.where(symm[ref_c] == s)[0]
                    idx_col = np.where(symm[sort_c] == s)[0]
                    col, row = np.meshgrid(idx_col, idx_row)
                    symm_product.append(mode_product[row, col])
                    irow.append(idx_row)
                    icol.append(idx_col)
            else:
                symm_product.append(mode_product)
                irow.append(np.array([i for i in range(nmode)], dtype=int))
                icol.append(np.array([i for i in range(nmode)], dtype=int))
            del mode_product # save some space

            # linear sum assignment of matrices of the same symmetry
            for pdt, row, col in zip(symm_product, irow, icol):
                rowidx, newidx = linear_sum_assignment(pdt, maximize=True)
                # change the sequence of cols
                freq[sort_c, col] = freq[sort_c, col[newidx]]
                eigvt[sort_c, col] = eigvt[sort_c, col[newidx]]
                if len(symm[0]) != 0:
                    symm[sort_c, col] = symm[sort_c, col[newidx]]

                # Very poor overlaps
                if len(np.where(pdt[rowidx, newidx] < mode_sort_tol)[0]) > 0:
                    raise ValueError(
                        'Poor continuity detected between Calc {:d} and Calc {:d}. Min eigenvector product = {:.4f}'.format(
                            ref_c, sort_c, np.min(pdt[rowidx, newidx])))
                # close overlaps
                ## update column index
                newcol = col[newidx]
                for ic, c in enumerate(newidx):
                    dpdt = pdt[ic, c] - pdt[ic, :]
                    clapidx = np.where((dpdt>0)&(dpdt<mode_sort_tol))[0]
                    if len(clapidx) == 0: continue
                    # from sub-matrix index to matrix index
                    close_overlap[sort_c, row[ic], newcol[clapidx]] = 1

        return freq, eigvt, close_overlap

    def _clean_thermoprop(self):
        """Clean fitted data. Called by 'thermo_\*' methods only."""
        props = ['volume', 'helmholtz', 'gibbs', 'entropy', 'c_v', 'c_p',
                 'k_t', 'k_s', 'alpha_v', 'gruneisen', ]
        for p in props:
            if hasattr(self, p): delattr(self, p)
        return self

    def eos_fit(self, volume, energy, method, **kwargs):
        """
        Fit energy-volume relationship by equation of states.

        Args:
            volume (array[float]): Unit: Angstrom^3
            energy (array[float]): Unit: kJ/mol
            method (str): Name of EoS used. Consistent with
                `Pymatgen <https://pymatgen.org/pymatgen.analysis.html#module-pymatgen.analysis.eos>`_.
            order (int): For DeltaFactor / Polynomial methods.
            min_ndata_factor, max_poly_order_factor, min_poly_order_factor (int):
                For the NumericalEOS method.

        Returns:
            eos (Pymatgen EOS): The fitted equation of state.
        """
        from pymatgen.analysis.eos import Murnaghan, Birch, BirchMurnaghan, \
            PourierTarantola, Vinet, DeltaFactor, NumericalEOS, PolynomialEOS

        classes = {
            "murnaghan"         : Murnaghan,
            "birch"             : Birch,
            "birch_murnaghan"   : BirchMurnaghan,
            "pourier_tarantola" : PourierTarantola,
            "vinet"             : Vinet,
            "deltafactor"       : DeltaFactor,
            "numerical_eos"     : NumericalEOS,
            "polynomial"        : PolynomialEOS,
        }
        try:
            eos = classes[method.lower()](volume, energy)
        except KeyError:
            raise ValueError("Unknown EOS method: '{}'.".format(method))
        eos_command = 'eos.fit('
        # Polynomial / Deltafactor / Numerical
        for key in kwargs.keys():
            if key in ['order', 'min_ndata_factor', 'max_poly_order_factor', 'min_poly_order']:
                eos_command += ', {}={}'.format(key, kwargs[value])
        eos_command += ')'
        eval(eos_command)

        # Deprecated methods
        if self.filefmt=='txt':
            ThermoQHA.old_write_eosfit(self, self.filename, close_overlap)
        return eos

    def freq_polynomial_fit(self, order):
        """
        Fit phonon frequencies as polynomial functions of volumes.

        Args:
            order (list[int] | array[int]): The order of polynomials used.
        """
        order = np.array(order, dtype=int, ndmin=1)

        # Polynomial without constant
        poly_fit = []; r2tot = np.zeros([self.nqpoint, self.nmode])
        dv = self.combined_volume - self.combined_volume[0]
        dfreq = (self.combined_freq.T - self.combined_freq[:, :, 0].T).T
        for iq, dfreq_q in enumerate(dfreq):
            fitq = []
            for im, df in enumerate(dfreq_q):
                freq = self.combined_freq[iq, im]
                if np.sum(np.abs(freq)) < 1e-2:
                    fitq.append(Polynomial([0. for i in range(order[0]+1)]))
                    r2tot[iq, im] = 1.
                else:
                    polys = []; r2s = []
                    for o in order:
                        coef, lst = polyfit(dv, df, deg=[i+1 for i in range(o)], full=True)
                        r2 = 1 - lst[0][0] / np.sum((df - np.mean(df))**2)
                        polys.append(Polynomial(coef))
                        r2s.append(r2)
                    idx = np.argmax(r2s)
                    fitq.append(polys[idx] + freq[0])
                    r2tot[iq, im] = r2s[idx]
            poly_fit.append(fitq)

        r2avg = np.mean(r2tot, axis=1)
        # Fit info saved for restart
        self.fit_order = order
        self.freq_fit = poly_fit

        # Deprecated methods
        if self.filefmt=='txt':
            Output.old_write_polyfit(self, r2tot, r2avg)
        return r2tot, r2avg

# -------------------------------- deprecated --------------------------------#
    def from_HA_files(self, *input_files, imaginary_tol=1e-4, q_overlap_tol=1e-4,
                      mode_sort_tol=0.4):
        """Deprecated. Call ``from_file()`` directly."""
        warn("Deprecated. Call 'from_file(source='crystal')' instead.", stacklevel=2)
        self.from_file(*input_files, source='crystal', mode_sort_tol=mode_sort_tol,
                       imaginary_tol=imaginary_tol, q_overlap_tol=q_overlap_tol)
        return self

    def from_QHA_file(self, input_file, imaginary_tol=1e-4,
                      q_overlap_tol=1e-4, mode_sort_tol=0.4):
        """Deprecated. Call ``from_file()`` directly."""
        warn("Deprecated. Call 'from_file(source='crystal-QHA')' instead.", stacklevel=2)
        self.from_file(input_file, source='crystal-QHA', mode_sort_tol=mode_sort_tol,
                       imaginary_tol=imaginary_tol, q_overlap_tol=q_overlap_tol)
        return self

    def from_phonopy_files(self, phono_yaml, struc_yaml=None, edft=None,
                           scale=1.0, imaginary_tol=1e-4, q_overlap_tol=1e-4,
                           q_id=None, q_coord=None):
        """Deprecated. Call ``from_file()`` directly."""
        warn("Deprecated. Call 'from_file(source='phonopy')' instead.", stacklevel=2)
        self.from_file(*phono_yaml, source='phonopy', struc_yaml=struc_yaml,
                       u_0=edft, scale=scale, mode_sort_tol=mode_sort_tol,
                       imaginary_tol=imaginary_tol, q_overlap_tol=q_overlap_tol,
                       q_id=q_id, q_coord=q_coord)
        return self

    # @staticmethod
    # def _poly_no_cst(param, x, y):
    #     """
    #     Define a polynomial :math:`\\Delta f(\\Delta x)` without constant term.
    #     Orders low to high. For SciPy. Functions of vectors not supported.
    #     """
    #     import numpy as np

    #     express = np.zeros([len(x)])
    #     for order, p in enumerate(param): express += p * x**(order + 1)
    #     return express - y

    # @staticmethod
    # def _minimize_latt(x, fe_eq, latt_ref, fe_ref):
    #     """
    #     Minimize the RMSD between :math:`\\mathbf{p}^{T}\\mathbf{Hp}` and the
    #     difference of Gibbs free energy. For Scipy. For fitting lattice
    #     parameters in ``self.expansion_vol``.
    #     """
    #     import numpy as np

    #     # Build lattice vector
    #     hess_dimen = latt_ref.shape[1]
    #     p = np.array(x[0:hess_dimen], ndmin=2)
    #     # Build Hessian
    #     Hess = np.zeros([hess_dimen, hess_dimen])
    #     hess_list = x[-int(hess_dimen * (hess_dimen + 1) / 2):]
    #     count_elem = 0
    #     for i in range(hess_dimen):
    #         for j in range(i, hess_dimen):
    #             Hess[i, j] = hess_list[count_elem]
    #             Hess[j, i] = hess_list[count_elem]
    #             count_elem += 1

    #     # Reference data
    #     dfe = fe_ref - fe_eq
    #     rmsd = 0.
    #     for idx_ref, ref in enumerate(latt_ref):
    #         dp = p - ref
    #         rmsd += ((dp @ Hess @ dp.T)[0, 0] - dfe[idx_ref])**2
    #     rmsd = (rmsd / latt_ref.shape[0])**0.5 # Return to RMS deviation
    #     return rmsd


class Phonopy():
    """
    The convertor between Phonopy and CRYSTALpytools file formats
    """
    # @classmethod
    # def read_structure(cls, file):
    #     """
    #     Read geometry from `Phonopy <https://phonopy.github.io/phonopy/>`_
    #     band.yaml, mesh.yaml, phonopy.yaml or phonopy_disp.yaml files.

    #     Args:
    #         file (str): Phonopy yaml file

    #     Returns:
    #         struc (Pymatgen Structure)

    #     :raise Exception: If the length unit in yaml file is neither 'au' nor 'angstrom'.
    #     """
    #     import yaml
    #     import numpy as np
    #     from CRYSTALpytools.units import au_to_angstrom
    #     from CRYSTALpytools.geometry import CStructure

    #     struc_file = open(file, 'r')
    #     data = yaml.safe_load(struc_file)
    #     struc_file.close()

    #     # Get unit
    #     try: # band.yaml
    #         len_unit = data['length_unit']
    #     except KeyError: # phonopy.yaml
    #         try:
    #             len_unit = data['physical_unit']['length']
    #         except KeyError:
    #             try:
    #                 _ = data['mesh']
    #                 len_unit = 'angstrom'
    #             except KeyError:
    #                 raise Exception("Unknown file format. Only 'band.yaml', 'mesh.yaml', 'phonopy.yaml' or 'phonopy_disp.yaml' are allowed.")

    #     if len_unit == 'angstrom':
    #         unit_len = 1.0
    #     elif len_unit == 'au':
    #         unit_len = au_to_angstrom(1.0)
    #     else:
    #         raise Exception("Unknown length unit. Available options: au, angstrom.")

    #     # Get structure
    #     spec = []
    #     coord = []
    #     try: # band.yaml / mesh.yaml
    #         latt = np.array(data['lattice'], dtype=float) * unit_len
    #         for idx_a, atom in enumerate(data['points']):
    #             spec.append(atom['symbol'])
    #             coord.append(atom['coordinates'])
    #     except KeyError: # phonopy.yaml
    #         latt = np.array(data['primitive_cell']['lattice'], dtype=float) * unit_len
    #         for idx_a, atom in enumerate(data['primitive_cell']['points']):
    #             spec.append(atom['symbol'])
    #             coord.append(atom['coordinates'])

    #     struc = CStructure(latt, spec, coord)
    #     return struc

    # @classmethod
    # def read_frequency(cls, file, q_id=None, q_coord=None):
    #     """
    #     Read phonon frequency from `Phonopy <https://phonopy.github.io/phonopy/>`_
    #     band.yaml, mesh.yaml or qpoints.yaml files. Frequency units must be THz
    #     (default of Phonopy).

    #     Args:
    #         file (str): Phonopy yaml file
    #         q_id (list[int]): Specify the id (from 0) of q points to be read.
    #             nqpoint\*1 list.
    #         q_coord (list[list]): Specify the coordinates of q points to be
    #             read. nqpoint\*3 list.

    #     ``q_id`` and ``q_coord`` should not be set simultaneously. If set,
    #     ``q_id`` takes priority and ``q_coord`` is ignored. If both are none,
    #     all the points will be read.

    #     .. note::

    #         Setting ``q_id`` or ``q_coord`` change their weights, i.e., the sum
    #         of their weights is renormalized to 1.

    #     Returns:
    #         qpoint (list): natom\*2 list. 1st element: 3\*1 array. Fractional
    #             coordinates of q points; 2nd element: float. Weight
    #         frequency (array): nqpint\*nmode array. Phonon frequency in THz.

    #     :raise Exception: If (some of) q point is not found.
    #     """
    #     import yaml
    #     import numpy as np
    #     import warnings

    #     phono_file = open(file, 'r', errors='ignore')
    #     data = yaml.safe_load(phono_file)
    #     phono_file.close()

    #     if np.all(q_id==None) and np.all(q_coord==None):
    #         nqpoint = data['nqpoint']
    #         qinfo = np.array(range(nqpoint), dtype=int)
    #     elif np.all(q_id!=None):
    #         qinfo = np.array(q_id, dtype=int)
    #         nqpoint = len(qinfo)
    #     elif np.all(q_id==None) and np.all(q_coord!=None):
    #         qinfo = np.array(q_coord, dtype=float)
    #         nqpoint = len(qinfo)

    #     natom = int(len(data['phonon'][0]['band']) / 3)
    #     qpoint = [[np.zeros([3, 1]), 1.] for i in range(nqpoint)]
    #     frequency = np.zeros([nqpoint, 3 * natom])
    #     # Read phonon
    #     real_q = 0
    #     for idx_p, phonon in enumerate(data['phonon']):
    #         if real_q == nqpoint: break
    #         if len(qinfo.shape) == 1: # q_id and all q points
    #             if idx_p != qinfo[real_q]:
    #                 continue
    #         else: # q_coord
    #             if np.linalg.norm(qinfo[real_q]-phonon['q-position']) > 1e-4:
    #                 continue
    #         qpoint[real_q][0] = np.array(phonon['q-position'])
    #         try:
    #             qpoint[real_q][1] = phonon['weight']
    #         except KeyError:
    #             qpoint[real_q][1] = 1
    #         frequency[real_q, :] = np.array([i['frequency'] for i in phonon['band']])
    #         real_q += 1

    #     if real_q < nqpoint:
    #         raise Exception('Some q points are missing from the yaml file.')
    #     return qpoint, frequency

    @classmethod
    def write_force_constants(cls, hessfile='HESSFREQ.DAT', phonopyfile='FORCE_CONSTANTS'):
        """
        Write Phonopy/VASP FORCE_CONSTANTS file by CRYSTAL HESSFREQ.DAT file.

        For example, to convert the calculation 'example' with a 4\*4\*4
        supercelland get phonon frequencies at Gamma point, use the following
        code:

        .. code-block:: python

            >>> from CRYSTALpytools.thermodynamics import Phonopy
            >>> Phonopy.write_force_constants(hessfile='example.HESSFREQ')
            >>> phonopy --crystal --qpoints='0 0 0' -c example.out --dim='4 4 4' --readfc

        Args:
            hessfile (str): The HESSFREQ.DAT file
            phonopyfile (str): The output name

        """
        import re
        import numpy as np
        from CRYSTALpytools.units import H_to_eV, angstrom_to_au

        # Note: Phonopy requires mass unweighted Hessian
        # Read hessfreq.dat
        file = open(hessfile, 'r')
        data = file.read()
        file.close()

        hess = np.array(data.strip().split(), dtype=float)
        natom = int((len(hess) / 9)**0.5)

        hess = np.reshape(hess, [3*natom, 3*natom], order='F')
        hess = angstrom_to_au(angstrom_to_au(H_to_eV(hess))) # Hartree.Bohr^-2 to eV.Angstrom^-2
        # Symmstrize Hessian with its lower half - Important. To address the print issue of HESSFREQ.DAT
        for i in range(3*natom):
            for j in range(i+1, 3*natom):
                hess[i, j] = hess[j, i]

        # Write force_constants
        file = open(phonopyfile, 'w')
        file.write('%4i%4i\n' % (natom, natom))
        for i in range(natom):
            for j in range(natom):
                file.write('%4i%4i\n' % (i + 1, j + 1))
                dynamic = hess[int(3 * i):int(3 * i + 3), int(3 * j):int(3 * j + 3)]
                for d in dynamic:
                    file.write('%22.15f%22.15f%22.15f\n' % (d[0], d[1], d[2]))

        file.close()


# class Output():
#     """
#     Deal with output data file
#     """
#     @classmethod
#     def write_expansion_latt(cls, qha, e_err, fit_order, r_square):
#         """
#         Write linear expansion information.

#         Args:
#             qha (Quasi_harmonic): :code:`CRYSTALpytools.thermodynamic.Quasi_harmonic`
#                 object.
#             e_err (array): RMS deviation of Gibbs free energy at T and p.
#             fit_order (array): The order of polynomials used for fitting
#                 lattice parameter.
#             r_square (array): R^2 of fitting. nLatt\*nPress
#         """
#         import numpy as np

#         idx_tmin = np.argmin(qha.temperature)
#         tmin = qha.temperature[idx_tmin]
#         nlatt = qha.lattice.shape[2]
#         nalpha = qha.alpha_latt.shape[2]

#         file = open(qha.filename, 'a+')
#         file.write('%s\n' % '# LINEAR THERMAL EXPANSION FIT')
#         file.write('%s\n' % '  Equilibrium lattices parameters are fitted with HA geometries.')
#         file.write('%s\n\n' % '  Lattice parameters at constant pressures are fitted as polynomial functions.')
#         for idx_p, p in enumerate(qha.pressure):
#             file.write('%s%6.2f%s\n\n' % ('## EQ. LATTICE AT ', p, '  GPa'))
#             file.write('%10s' % 'T(K)')
#             for i in range(nlatt):
#                 file.write('%18s%2i' % ('Latt. Param. -', i + 1))
#             file.write('%20s\n' % 'RMSD (kJ/mol)')
#             for idx_t, tempt in enumerate(qha.temperature):
#                 file.write('%10.2f' % tempt)
#                 for i in range(nlatt):
#                     file.write('%20.6f' % qha.lattice[idx_p, idx_t, i])
#                 file.write('%20.6f\n' % e_err[idx_p, idx_t])
#             file.write('\n')
#             file.write('%s%6.2f%s\n\n' % ('## LATTICE EXPANSION AT ', p, '  GPa'))
#             for i in range(nlatt):
#                 file.write('%s%8i\n' % ('  Latt. Param. No. =', i + 1))
#                 file.write('%s%8i\n' % ('  Order of fitting =', fit_order[i]))
#                 file.write('%s%8.4f\n\n' % ('  R^2 of fitting   =', r_square[i, idx_p]))
#             file.write('%10s' % 'T(K)')
#             for i in range(nalpha):
#                 file.write('%18s%2i' % ('alpha_l(K^-1) -', i + 1))
#             file.write('\n')
#             for idx_t, tempt in enumerate(qha.temperature):
#                 file.write('%10.2f' % tempt)
#                 for i in range(nlatt):
#                     file.write('%20.8e' % qha.alpha_latt[idx_p, idx_t, i])
#                 file.write('\n')
#             file.write('\n')

#         file.write('\n')
#         file.close()
#         return
